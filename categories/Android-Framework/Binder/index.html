<!DOCTYPE html>
<html lang="zh">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
<title>分类: Binder - 半山的博客</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



    <meta name="description" content="半山的博客，主要记录一些技术分享和生活杂谈。喜欢研究Android Framework和ART虚拟机，希望能输出一些高质量的文章，即构建自己的知识体系，也帮助到大家。">
<meta name="keywords" content="半山,Android,Framework,ART,虚拟机,Java">
<meta property="og:type" content="website">
<meta property="og:title" content="半山的博客">
<meta property="og:url" content="https://banshan.tech/categories/Android-Framework/Binder/index.html">
<meta property="og:site_name" content="半山的博客">
<meta property="og:description" content="半山的博客，主要记录一些技术分享和生活杂谈。喜欢研究Android Framework和ART虚拟机，希望能输出一些高质量的文章，即构建自己的知识体系，也帮助到大家。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://banshan.tech/images/og_image.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="半山的博客">
<meta name="twitter:description" content="半山的博客，主要记录一些技术分享和生活杂谈。喜欢研究Android Framework和ART虚拟机，希望能输出一些高质量的文章，即构建自己的知识体系，也帮助到大家。">
<meta name="twitter:image" content="https://banshan.tech/images/og_image.png">







<link rel="icon" href="/images/banshan.png">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/agate.css">


    
    
    
    <style>body>.footer,body>.navbar,body>.section{opacity:0}</style>
    

    
    
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">
    

    
    

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">


    
    
    
    

<link rel="stylesheet" href="/css/back-to-top.css">


    
    

    
    
    
    

    
    
<link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

    
    
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    

    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-2-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/banshan.png" alt="半山的博客" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item" href="/">主页</a>
                
                <a class="navbar-item" href="/archives">归档</a>
                
                <a class="navbar-item" href="/categories">分类</a>
                
                <a class="navbar-item" href="/tags">标签</a>
                
                <a class="navbar-item" href="/about">关于</a>
                
            </div>
            
            <div class="navbar-end">
                
                
                
                <a class="navbar-item search" title="搜索" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-9-tablet is-9-desktop is-9-widescreen has-order-2 column-main"><div class="card">
    <div class="card-content">
        <nav class="breadcrumb" aria-label="breadcrumbs">
        <ul>
            <li><a href="/categories">分类</a></li>
            
            <li><a href="/categories/Android-Framework/">Android Framework</a></li>
            
            <li class="is-active"><a href="#" aria-current="page">Binder</a></li>
        </ul>
        </nav>
    </div>
</div>

    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-10-10T08:00:00.000Z">2019-10-10</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Android-Framework/">Android Framework</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Android-Framework/Binder/">Binder</a>
                </div>
                
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/10/10/Binder概述/">Binder概述</a>
            
        </h1>
        <div class="content">
            <p>在编程的世界中，不同进程间的通信、协同、合作随处可见。很多时候，人们习惯用IPC(<code>I</code>nter <code>P</code>rocess <code>C</code>ommunication，跨进程通信)来称呼它们。譬如Binder在多数情况下也被称为Android世界中的IPC机制。但如果以应用开发者的视角来看，Binder也可以称为Android世界中的RPC(<code>R</code>emote <code>P</code>rocedure <code>C</code>all，远程过程调用)机制。</p>
<ul>
<li><p>IPC(<code>I</code>nter <code>P</code>rocess <code>C</code>ommunication，跨进程通信)</p>
<p>泛指一切用于进程间传递信息量（传输数据只是传递信息量的一个子集）的方式，譬如socket/pipe/FIFO/semaphore等。这些名称表征的是信息传输的具体方式，而不涉及信息的处理和加工。</p>
</li>
<li><p>RPC(<code>R</code>emote <code>P</code>rocedure <code>C</code>all，远程过程调用)</p>
<p>一种建构于IPC基础之上的方法调用。对于客户端而言，它可以感知到的仅仅是方法调用和获取返回值两个过程。然而实际上这个方法内部完成了客户端参数打包，数据传输，服务端数据解包，服务端数据处理，服务端结果返回等一系列中间过程。只不过这些过程对于客户端而言都是“透明”的。所以可以说IPC只是RPC中的一个环节，除此之外，RPC还包含数据打包，解包以及处理的过程，它们可以统称为信息的处理和加工过程。</p>
</li>
</ul>
<h2 id="1-Android中为什么需要大量的RPC？"><a href="#1-Android中为什么需要大量的RPC？" class="headerlink" title="1. Android中为什么需要大量的RPC？"></a>1. Android中为什么需要大量的RPC？</h2><p>下面举一个剪贴板的例子，来直观地呈现RPC的内涵。</p>
<p>通过如下代码，我们可以将一段文字复制到剪贴板。在执行第8行代码后，便可以将文本复制到剪贴板上。这里事先透露下，第8行代码本质上是一个RPC。</p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-number">1</span>    <span class="hljs-comment">// 获取系统剪贴板</span></span><br><span class="line"><span class="hljs-number">2</span>    ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);</span><br><span class="line"><span class="hljs-number">3</span>    </span><br><span class="line"><span class="hljs-number">4</span>    <span class="hljs-comment">// 创建一个剪贴数据集，包含一个普通文本数据条目（需要复制的数据）</span></span><br><span class="line"><span class="hljs-number">5</span>    ClipData clipData = ClipData.newPlainText(<span class="hljs-keyword">null</span>, <span class="hljs-string">"需要复制的文本数据"</span>);</span><br><span class="line"><span class="hljs-number">6</span>    </span><br><span class="line"><span class="hljs-number">7</span>    <span class="hljs-comment">// 把数据集设置（复制）到剪贴板</span></span><br><span class="line"><span class="hljs-number">8</span>    clipboard.setPrimaryClip(clipData);</span><br></pre></td></tr></table></figure>

<p>那么RPC和非RPC的差异到底在什么地方呢？下面用一幅图来解释这个问题。</p>
<p><img src="https://raw.githubusercontent.com/banshann/Picbed/master/RPC%E7%9A%84%E6%9C%AC%E8%B4%A8.jpg" alt="RPC与非RPC的区别"></p>
<p>在RPC的过程中，进程B来进行真正的方法执行，相当于为进程A提供了某种服务，因此进程B在RPC的过程中也可以称为Server进程，进程A对应地可以称为Client进程。</p>
<p>接着再来讨论一个问题，为什么Android中需要使用大量的RPC？将RPC换成本地方法不可以么？</p>
<p>答案是不可以。因为Android本身是一个中心化管理的系统，RPC可以保证一个Server进程管理众多Client进程的调用请求，且能够实现系统状态的统一管理。举个例子，如果我们在一个App中将一段文字复制到剪贴板，假设这个复制过程是调用本地方法完成的（复制状态仅局限于App进程），那么离开这个App后新的剪贴板就不会再有这段文字。反之，如果我们采用RPC来完成复制，那么最终的文字将传递给了Server进程。而Server进程通常是常驻内存，所以即便我们离开App，剪贴板上的文字也依然存在，保证它可以被粘贴到其他App中。在Android中，大量的系统服务都是在system_server进程中完成各自功能的，譬如ActivityManagerService。</p>
<h2 id="2-Binder世界里的service到底是什么概念？"><a href="#2-Binder世界里的service到底是什么概念？" class="headerlink" title="2. Binder世界里的service到底是什么概念？"></a>2. Binder世界里的service到底是什么概念？</h2><p>在进行具体阐述之前，我们先要做一个限定。以下所讨论的service是类似于ActivityManagerService、PackageManagerService、WindowManagerService等一系列的服务，它们是Binder语义下的service，而不是Android四大组件中的service。</p>
<p>不过“服务(service)”到底是什么意思呢？它是一类近似功能的统称。譬如“商人的服务”，就可以包含“购买薯片”、“购买可乐”、“购买沙发”、“购买电视”等一系列功能。ActivityManagerService是一个类，它里面定义实现了很多方法，详细描述了每一项功能应该来如何提供。但是它只是一个模板，是无法实际提供服务的。真正提供服务的是ActivityManagerService实例化出来的对象。在Android中，ActivityManagerService只会实例化出来一个对象，而它就是真正为应用提供AMS服务的人。</p>
<p><a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java#2877" target="_blank" rel="noopener">/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</a></p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-number">2877</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lifecycle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SystemService</span> </span>&#123;</span><br><span class="line"><span class="hljs-number">2878</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ActivityManagerService mService;</span><br><span class="line"><span class="hljs-number">2879</span></span><br><span class="line"><span class="hljs-number">2880</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Lifecycle</span><span class="hljs-params">(Context context)</span> </span>&#123;</span><br><span class="line"><span class="hljs-number">2881</span>            <span class="hljs-keyword">super</span>(context);</span><br><span class="line"><span class="hljs-number">2882</span>            mService = <span class="hljs-keyword">new</span> ActivityManagerService(context);</span><br><span class="line"><span class="hljs-number">2883</span>        &#125;</span><br></pre></td></tr></table></figure>

<p>这个对象是在system_server进程启动的时候创建出来的，具体是在ActivityManagerService.Lifecycle的构造过程中完成。</p>
<p><a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/services/java/com/android/server/SystemServer.java#559" target="_blank" rel="noopener">/frameworks/base/services/java/com/android/server/SystemServer.java</a></p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-number">559</span>        mActivityManagerService = mSystemServiceManager.startService(</span><br><span class="line"><span class="hljs-number">560</span>                ActivityManagerService.Lifecycle.class).getService();</span><br></pre></td></tr></table></figure>

<p>由于整个系统中，ActivityManagerService实例化的对象只有一个，所以将它称为“AMS”、“AMS实例化的对象”都无所谓。这就好比整个饭店就一个厨师，你叫他“厨师”还是“王厨师”都不影响理解。</p>
<h3 id="2-1-service与进程-线程的关系"><a href="#2-1-service与进程-线程的关系" class="headerlink" title="2.1 service与进程/线程的关系"></a>2.1 service与进程/线程的关系</h3><p>如果将service看作一个可以提供服务的Java对象，那么这个问题将会迎刃而解。</p>
<p>Java对象是存放在堆上的，因此可以在同一个进程里的不同线程间共享，所以service（准确来说应该是service对象的方法）也可以在不同的线程里运行。</p>
<p>另外，一个进程里可以构造出成千上万的对象，因此一个进程里也可以存在成千上万的service。而且同一个类型的service也可以存在很多个，譬如我们可以在system_server进程中同时构造ActivityManagerService对象A/B/C，三个AMS对象表示三个可以提供服务的实体，这就好比饭店里现在有了三个厨师，你可以跟其中任何一个请求服务。当然，在实际的Android系统中，同一个类型的service多数情况下只有一个对象。但现实情况不存在并不代表理论上不可实现，所以理论上同一个类型的service可以在一个进程中存在多个对象。</p>
<h2 id="3-RPC的内部是如何构成的？"><a href="#3-RPC的内部是如何构成的？" class="headerlink" title="3. RPC的内部是如何构成的？"></a>3. RPC的内部是如何构成的？</h2><p>本文开篇提到，对于客户端而言，它可以感知到的仅仅是方法调用和获取返回值两个过程。那么具体到剪贴板这个例子来的话，对于Android应用的开发者而言，他感知到的只有下面两件事：</p>
<p>对于Android应用的开发者而言，他感知到的只有下面两件事：</p>
<ol>
<li>我调用了clipboard.setPrimaryClip()方法</li>
<li>剪贴板上出现了我想要复制的文字</li>
</ol>
<p>在这个过程中，应用开发者根本感知不到这是一次跨进程的调用，也感受不到调用背后的数据传输。RPC机制将这一切都封装了起来，因此开发者可以天真地认为所有这一切都发生在应用进程。而这也正是系统设计者希望给开发者带去的便利和简化，既是理解上的简化，也是使用上的简化。</p>
<p>不过一个有追求的开发者通常只会选择使用上的简化，而不会局限在理解上的简化。所以下面我将用一种颇具趣味性的方式来继续阐述。</p>
<h3 id="3-1-“人才中心”的例子"><a href="#3-1-“人才中心”的例子" class="headerlink" title="3.1 “人才中心”的例子"></a>3.1 “人才中心”的例子</h3><p>所有的算法和设计模式都是从社会生活中抽象提炼出来的。所以本着“从群众中来，到群众中去”的原则，我们赋予冰冷的源码以生命，从社会生活的角度来理解RPC，来理解Binder。</p>
<p>前几年，城市里面新建了几座各具特色的人才中心，每一个中心都汇聚了来自五湖四海的奇人异士。他们中有手艺精湛的厨师，有投机倒把的商人，有妙笔生花的作家，还有勤勤恳恳的果农。人才中心有很多电话间，方便他们打电话的时候互不干扰。有一天，小明想从人才中心A里面的贾商人那里买一个键盘，于是拨通了A大厦的电话……</p>
<p>上面的例子完全可以映射成一次RPC。人才中心表示进程，电话间表示线程，职业表示service所属的类，贾商人表示一个具体的提供service的对象，买键盘表示服务的方法，打电话表示数据传输的方式，小明表示Client进程。</p>
<p><strong>小明打电话给人才中心A</strong>：Client进程跟Server进程A通信，除此之外，Client进程也可以跟Server进程B/C/D通信。</p>
<p><strong>小明想找贾商人买一个键盘</strong>（伪代码表示如下）：</p>
<p>第1行表示贾商人出现了，第2行表示他在人才登记处（非人才中心）将自己的名字登记在册。</p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-number">1</span>    Merchant jia = <span class="hljs-keyword">new</span> Merchant(<span class="hljs-string">"Jia"</span>);</span><br><span class="line"><span class="hljs-number">2</span>    ServiceManager.addService(<span class="hljs-string">"MerchantJia"</span>, jia);</span><br></pre></td></tr></table></figure>

<p>下面的代码表示小明打电话购买键盘的过程。第1行表示他从人才登记处要到了贾商人的号码，第2行表示他打电话给贾商人提出购买键盘的请求。贾商人接到请求后，立马发货，返回值result表明小明收到了键盘。</p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-number">1</span>    IMerchant merchantJia = IMerchant.Stub.asInterface(ServiceManager.getService(<span class="hljs-string">"MerchantJia"</span>));</span><br><span class="line"><span class="hljs-number">2</span>    Keyboard result = merchantJia.buyKeyboard();</span><br></pre></td></tr></table></figure>

<p>那如果小明不想找贾商人买了，换成甄商人会怎么样？</p>
<p>甄商人在人才登记处（非人才中心）登记：</p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-number">1</span>    Merchant zhen = <span class="hljs-keyword">new</span> Merchant(<span class="hljs-string">"Zhen"</span>);</span><br><span class="line"><span class="hljs-number">2</span>    ServiceManager.addService(<span class="hljs-string">"MerchantZhen"</span>, zhen);</span><br></pre></td></tr></table></figure>

<p>小明打电话购买键盘：</p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-number">1</span>    IMerchant merchantZhen = IMerchant.Stub.asInterface(ServiceManager.getService(<span class="hljs-string">"MerchantZhen"</span>));</span><br><span class="line"><span class="hljs-number">2</span>    Keyboard result = merchantZhen.buyKeyboard();</span><br></pre></td></tr></table></figure>

<p>不管是贾商人还是甄商人，他们都是商人，因此都是由Merchant类实例化而来。因此，职业“商人”就映射为了“Merchant”类，而类实例化出来的对象就是具体提供service的对象（贾商人和甄商人），表示提供某一类服务的实体。</p>
<p><strong>贾商人去电话间接电话：</strong></p>
<p>人才中心接线员收到小明的电话，说要找贾商人，于是给贾商人分配了电话间D。之所以分配D，是因为A/B/C三个电话间现在都有人在使用。类比回源码，人才中心表示Server进程， 电话间表示线程。</p>
<p>人才中心接收到小明的请求，表示Server进程接收到Client进程的数据。之后便决定将它交由贾商人处理，表示Server进程会将Client传输过来的数据交由MerchantJia这个对象来处理。接着是分配电话间，A/B/C三个电话间正在被使用，表示目前有三个Binder线程正在处理其他请求。于是最终将电话间D分配给贾商人，表示service的方法接下来将运行在线程D中。</p>
<h3 id="3-2-剪贴板的例子"><a href="#3-2-剪贴板的例子" class="headerlink" title="3.2 剪贴板的例子"></a>3.2 剪贴板的例子</h3><p>接下来以上文中剪贴板复制文本的代码为样本，来阐述一次RPC中所涵盖的具体过程。</p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-number">1</span>    <span class="hljs-comment">// 获取系统剪贴板</span></span><br><span class="line"><span class="hljs-number">2</span>    ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);</span><br><span class="line"><span class="hljs-number">3</span>    </span><br><span class="line"><span class="hljs-number">4</span>    <span class="hljs-comment">// 创建一个剪贴数据集，包含一个普通文本数据条目（需要复制的数据）</span></span><br><span class="line"><span class="hljs-number">5</span>    ClipData clipData = ClipData.newPlainText(<span class="hljs-keyword">null</span>, <span class="hljs-string">"需要复制的文本数据"</span>);</span><br><span class="line"><span class="hljs-number">6</span>    </span><br><span class="line"><span class="hljs-number">7</span>    <span class="hljs-comment">// 把数据集设置（复制）到剪贴板</span></span><br><span class="line"><span class="hljs-number">8</span>    clipboard.setPrimaryClip(clipData);</span><br></pre></td></tr></table></figure>

<h4 id="3-2-1-service对象的创建过程"><a href="#3-2-1-service对象的创建过程" class="headerlink" title="3.2.1 service对象的创建过程"></a>3.2.1 service对象的创建过程</h4><p>剪贴板服务对象位于system_server进程，而它的代理对象则可以分布在所有需要此项服务的App进程中。</p>
<p>因此，剪贴板服务对象的创建也发生在system_server进程（Server进程）。它是ClipboardImpl类型，这个类里面的方法就是剪贴板服务的具体实现。</p>
<p><a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/services/core/java/com/android/server/clipboard/ClipboardService.java#232" target="_blank" rel="noopener">/frameworks/base/services/core/java/com/android/server/clipboard/ClipboardService.java</a></p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-number">232</span>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClipboardImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IClipboard</span>.<span class="hljs-title">Stub</span> </span>&#123;</span><br><span class="line"><span class="hljs-number">233</span>        <span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-number">234</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onTransact</span><span class="hljs-params">(<span class="hljs-keyword">int</span> code, Parcel data, Parcel reply, <span class="hljs-keyword">int</span> flags)</span></span></span><br><span class="line"><span class="hljs-function">235                <span class="hljs-keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"><span class="hljs-number">236</span>            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-number">237</span>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line"><span class="hljs-number">238</span>            &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line"><span class="hljs-number">239</span>                <span class="hljs-keyword">if</span> (!(e <span class="hljs-keyword">instanceof</span> SecurityException)) &#123;</span><br><span class="line"><span class="hljs-number">240</span>                    Slog.wtf(<span class="hljs-string">"clipboard"</span>, <span class="hljs-string">"Exception: "</span>, e);</span><br><span class="line"><span class="hljs-number">241</span>                &#125;</span><br><span class="line"><span class="hljs-number">242</span>                <span class="hljs-keyword">throw</span> e;</span><br><span class="line"><span class="hljs-number">243</span>            &#125;</span><br><span class="line"><span class="hljs-number">244</span></span><br><span class="line"><span class="hljs-number">245</span>        &#125;</span><br><span class="line"><span class="hljs-number">246</span></span><br><span class="line"><span class="hljs-number">247</span>        <span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-number">248</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPrimaryClip</span><span class="hljs-params">(ClipData clip, String callingPackage)</span> </span>&#123;</span><br><span class="line"><span class="hljs-number">249</span>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;</span><br><span class="line"><span class="hljs-number">250</span>                <span class="hljs-keyword">if</span> (clip == <span class="hljs-keyword">null</span> || clip.getItemCount() &lt;= <span class="hljs-number">0</span>) &#123;</span><br><span class="line"><span class="hljs-number">251</span>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"No items"</span>);</span><br><span class="line"><span class="hljs-number">252</span>                &#125;</span><br><span class="line"><span class="hljs-number">253</span>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line"><span class="hljs-number">254</span>                <span class="hljs-keyword">if</span> (!clipboardAccessAllowed(AppOpsManager.OP_WRITE_CLIPBOARD, callingPackage,</span><br><span class="line"><span class="hljs-number">255</span>                            callingUid)) &#123;</span><br><span class="line"><span class="hljs-number">256</span>                    <span class="hljs-keyword">return</span>;</span><br><span class="line"><span class="hljs-number">257</span>                &#125;</span><br><span class="line"><span class="hljs-number">258</span>                checkDataOwnerLocked(clip, callingUid);</span><br><span class="line"><span class="hljs-number">259</span>                setPrimaryClipInternal(clip, callingUid);</span><br><span class="line"><span class="hljs-number">260</span>            &#125;</span><br><span class="line"><span class="hljs-number">261</span>        &#125;</span><br></pre></td></tr></table></figure>

<p>剪贴板服务对象是在ClipboardService.onStart方法中创建并注册到ServiceManager中的，整个过程都发生在system_server进程的启动过程中。</p>
<p><a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/services/core/java/com/android/server/clipboard/ClipboardService.java#192" target="_blank" rel="noopener">/frameworks/base/services/core/java/com/android/server/clipboard/ClipboardService.java</a></p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-number">192</span>    <span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-number">193</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-number">194</span>        publishBinderService(Context.CLIPBOARD_SERVICE, <span class="hljs-keyword">new</span> ClipboardImpl());</span><br><span class="line"><span class="hljs-number">195</span>    &#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/services/java/com/android/server/SystemServer.java#1064" target="_blank" rel="noopener">/frameworks/base/services/java/com/android/server/SystemServer.java</a></p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-number">1064</span>            traceBeginAndSlog(<span class="hljs-string">"StartClipboardService"</span>);</span><br><span class="line"><span class="hljs-number">1065</span>            mSystemServiceManager.startService(ClipboardService.class);</span><br><span class="line"><span class="hljs-number">1066</span>            traceEnd();</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-寻找service对象的代理对象"><a href="#3-2-2-寻找service对象的代理对象" class="headerlink" title="3.2.2 寻找service对象的代理对象"></a>3.2.2 寻找service对象的代理对象</h4><figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-number">1</span>    <span class="hljs-comment">// 获取系统剪贴板</span></span><br><span class="line"><span class="hljs-number">2</span>    ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);</span><br><span class="line"><span class="hljs-number">3</span>    </span><br><span class="line"><span class="hljs-number">4</span>    <span class="hljs-comment">// 创建一个剪贴数据集，包含一个普通文本数据条目（需要复制的数据）</span></span><br><span class="line"><span class="hljs-number">5</span>    ClipData clipData = ClipData.newPlainText(<span class="hljs-keyword">null</span>, <span class="hljs-string">"需要复制的文本数据"</span>);</span><br><span class="line"><span class="hljs-number">6</span>    </span><br><span class="line"><span class="hljs-number">7</span>    <span class="hljs-comment">// 把数据集设置（复制）到剪贴板</span></span><br><span class="line"><span class="hljs-number">8</span>    clipboard.setPrimaryClip(clipData);</span><br></pre></td></tr></table></figure>

<p>寻找代理对象的过程发生在Client进程中。上面第2行的clipboard对象是一层封装，其内部就是剪贴板服务对象的代理对象（原谅我表述得这么拗口，但为了含义的准确表达，牺牲一些语言的美感也无可厚非）。</p>
<p><a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/app/ContextImpl.java#1719" target="_blank" rel="noopener">/frameworks/base/core/java/android/app/ContextImpl.java</a></p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-number">1719</span>    <span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-number">1720</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getSystemService</span><span class="hljs-params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="hljs-number">1721</span>        <span class="hljs-keyword">return</span> SystemServiceRegistry.getSystemService(<span class="hljs-keyword">this</span>, name);</span><br><span class="line"><span class="hljs-number">1722</span>    &#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/app/SystemServiceRegistry.java#1012" target="_blank" rel="noopener">/frameworks/base/core/java/android/app/SystemServiceRegistry.java</a></p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-number">1012</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getSystemService</span><span class="hljs-params">(ContextImpl ctx, String name)</span> </span>&#123;</span><br><span class="line"><span class="hljs-number">1013</span>        ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);</span><br><span class="line"><span class="hljs-number">1014</span>        <span class="hljs-keyword">return</span> fetcher != <span class="hljs-keyword">null</span> ? fetcher.getService(ctx) : <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-number">1015</span>    &#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/app/SystemServiceRegistry.java#178" target="_blank" rel="noopener">/frameworks/base/core/java/android/app/SystemServiceRegistry.java</a></p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-number">178</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS =</span><br><span class="line"><span class="hljs-number">179</span>            <span class="hljs-keyword">new</span> HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure>

<p><a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/app/SystemServiceRegistry.java#261" target="_blank" rel="noopener">/frameworks/base/core/java/android/app/SystemServiceRegistry.java</a></p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-number">261</span>        registerService(Context.CLIPBOARD_SERVICE, ClipboardManager.class,</span><br><span class="line"><span class="hljs-number">262</span>                <span class="hljs-keyword">new</span> CachedServiceFetcher&lt;ClipboardManager&gt;() &#123;</span><br><span class="line"><span class="hljs-number">263</span>            <span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-number">264</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> ClipboardManager <span class="hljs-title">createService</span><span class="hljs-params">(ContextImpl ctx)</span> <span class="hljs-keyword">throws</span> ServiceNotFoundException </span>&#123;</span><br><span class="line"><span class="hljs-number">265</span>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ClipboardManager(ctx.getOuterContext(),</span><br><span class="line"><span class="hljs-number">266</span>                        ctx.mMainThread.getHandler());</span><br><span class="line"><span class="hljs-number">267</span>            &#125;&#125;);</span><br></pre></td></tr></table></figure>

<p>SYSTEM_SERVICE_FETCHERS是一个HashMap，它以键值对的方式存储了很多系统服务对象的代理对象（或其wrapper对象）。对剪贴板而言，getSystemService方法最终会创建一个ClipboardManager对象并返回。</p>
<p><a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/content/ClipboardManager.java#85" target="_blank" rel="noopener">/frameworks/base/core/java/android/content/ClipboardManager.java</a></p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-number">85</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClipboardManager</span><span class="hljs-params">(Context context, Handler handler)</span> <span class="hljs-keyword">throws</span> ServiceNotFoundException </span>&#123;</span><br><span class="line"><span class="hljs-number">86</span>        mContext = context;</span><br><span class="line"><span class="hljs-number">87</span>        mHandler = handler;</span><br><span class="line"><span class="hljs-number">88</span>        mService = IClipboard.Stub.asInterface(</span><br><span class="line"><span class="hljs-number">89</span>                ServiceManager.getServiceOrThrow(Context.CLIPBOARD_SERVICE));</span><br><span class="line"><span class="hljs-number">90</span>    &#125;</span><br></pre></td></tr></table></figure>

<p>ClipboardManager的构造方法里，88行尤为关键。首先根据字符串”clipboard”去ServiceManger中找到剪贴板服务对象的代理对象，此时获得的代理对象只具有跨进程通信的能力。接着通过asInterface为这个代理对象赋予剪贴板的能力。</p>
<p><a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/content/Context.java#3727" target="_blank" rel="noopener">/frameworks/base/core/java/android/content/Context.java</a></p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-number">3727</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CLIPBOARD_SERVICE = <span class="hljs-string">"clipboard"</span>;</span><br></pre></td></tr></table></figure>

<p>对于Java而言，接口相当于一种能力。在Binder的世界中，一个服务对象的代理对象通常封装了特定的服务接口，譬如剪贴板就是IClipboard，表示该对象具有剪贴板服务所能提供的诸多能力，譬如复制文字、粘贴文字等。另外，该代理对象内部有个字段封装了IBinder接口，表示该字段具有跨进程通信的能力，它在每次IPC的过程中都会发挥作用。</p>
<p>IClipboard.Stub是AIDL文件自动生成的一个类，在最终生成的文件中还有一个类是IClipboard.Stub.Proxy，它们是Binder原生类的一层封装。相较于Binder原生类，它们多了一层数据打包和解包的过程。</p>
<p><u><em>IClipboard.java（源码中没有，是在编译时由IClipboard.aidl文件间接生成的）</em></u></p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-number">1</span>    <span class="hljs-comment">/** Local-side IPC implementation stub class. */</span></span><br><span class="line"><span class="hljs-number">2</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">android</span>.<span class="hljs-title">os</span>.<span class="hljs-title">Binder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">android</span>.<span class="hljs-title">content</span>.<span class="hljs-title">IClipboard</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-number">1</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">android</span>.<span class="hljs-title">content</span>.<span class="hljs-title">IClipboard</span></span></span><br></pre></td></tr></table></figure>

<p>IClipboard.Stub.asInterface方法给原本只具有IBinder（跨进程通信）能力的对象赋予IClipboard（剪贴板）能力。这样一来，得到的代理对象就同时兼具了跨进程通信的能力和剪贴板的能力。跨进程通信的能力对开发者而言是透明的，而剪贴板的能力才是他们真正关心的。</p>
<h4 id="3-2-3-通过代理对象进行RPC"><a href="#3-2-3-通过代理对象进行RPC" class="headerlink" title="3.2.3 通过代理对象进行RPC"></a>3.2.3 通过代理对象进行RPC</h4><p>最终调用clipboard.setPrimaryClip(clipData)往剪贴板上写数据时，实际底层调用的却是mService.setPrimaryClip方法，mService就是刚刚通过asInterface得到的代理对象。</p>
<p><a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/content/ClipboardManager.java#100" target="_blank" rel="noopener">/frameworks/base/core/java/android/content/ClipboardManager.java</a></p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-number">100</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPrimaryClip</span><span class="hljs-params">(@NonNull ClipData clip)</span> </span>&#123;</span><br><span class="line"><span class="hljs-number">101</span>        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-number">102</span>            Preconditions.checkNotNull(clip);</span><br><span class="line"><span class="hljs-number">103</span>            clip.prepareToLeaveProcess(<span class="hljs-keyword">true</span>);</span><br><span class="line"><span class="hljs-number">104</span>            mService.setPrimaryClip(clip, mContext.getOpPackageName());</span><br><span class="line"><span class="hljs-number">105</span>        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line"><span class="hljs-number">106</span>            <span class="hljs-keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line"><span class="hljs-number">107</span>        &#125;</span><br><span class="line"><span class="hljs-number">108</span>    &#125;</span><br></pre></td></tr></table></figure>

<p>mService.setPrimaryClip方法最终调用的是IClipboard.Stub.Proxy.setPrimaryClip方法，将参数打包放入 _data中，并从 _reply中解包读出Server端传输过来的返回值（这个用来示例的方法中没有返回值）。而真正的跨进程传输是通过下面第16行完成的。mRemote的类型为android.os.IBinder，表明它具有跨进程传输的能力。调用它的transact方法表示将打包后的参数发送给Server进程。</p>
<p><u><em>IClipboard.java（源码中没有，是在编译时由IClipboard.aidl文件间接生成的）</em></u></p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-number">1</span>    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPrimaryClip</span><span class="hljs-params">(android.content.ClipData clip, java.lang.String callingPackage, <span class="hljs-keyword">int</span> userId)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="hljs-function">2    </span>&#123;</span><br><span class="line"><span class="hljs-number">3</span>      android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line"><span class="hljs-number">4</span>      android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line"><span class="hljs-number">5</span>      <span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-number">6</span>        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line"><span class="hljs-number">7</span>        <span class="hljs-keyword">if</span> ((clip!=<span class="hljs-keyword">null</span>)) &#123;</span><br><span class="line"><span class="hljs-number">8</span>          _data.writeInt(<span class="hljs-number">1</span>);</span><br><span class="line"><span class="hljs-number">9</span>          clip.writeToParcel(_data, <span class="hljs-number">0</span>);</span><br><span class="line"><span class="hljs-number">10</span>       &#125;</span><br><span class="line"><span class="hljs-number">11</span>       <span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-number">12</span>         _data.writeInt(<span class="hljs-number">0</span>);</span><br><span class="line"><span class="hljs-number">13</span>       &#125;</span><br><span class="line"><span class="hljs-number">14</span>       _data.writeString(callingPackage);</span><br><span class="line"><span class="hljs-number">15</span>       _data.writeInt(userId);</span><br><span class="line"><span class="hljs-number">16</span>       <span class="hljs-keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_setPrimaryClip, _data, _reply, <span class="hljs-number">0</span>);</span><br><span class="line"><span class="hljs-number">17</span>       <span class="hljs-keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-number">18</span>         getDefaultImpl().setPrimaryClip(clip, callingPackage, userId);</span><br><span class="line"><span class="hljs-number">19</span>         <span class="hljs-keyword">return</span>;</span><br><span class="line"><span class="hljs-number">20</span>       &#125;</span><br><span class="line"><span class="hljs-number">21</span>       _reply.readException();</span><br><span class="line"><span class="hljs-number">22</span>     &#125;</span><br><span class="line"><span class="hljs-number">23</span>     <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line"><span class="hljs-number">24</span>       _reply.recycle();</span><br><span class="line"><span class="hljs-number">25</span>       _data.recycle();</span><br><span class="line"><span class="hljs-number">26</span>     &#125;</span><br><span class="line"><span class="hljs-number">27</span>   &#125;</span><br></pre></td></tr></table></figure>

<p>数据传输的过程最终由Binder Driver来负责，所以上述的transact方法最终会通过<code>ioctl</code>的系统调用进入到内核空间，通过一系列的驱动函数将数据发送给Server进程。</p>
<h4 id="3-2-4-服务对象处理接收到的请求"><a href="#3-2-4-服务对象处理接收到的请求" class="headerlink" title="3.2.4 服务对象处理接收到的请求"></a>3.2.4 服务对象处理接收到的请求</h4><p>Server进程接收到Client进程传输来的参数数据后，就会开始实际的处理。这里我们跳过Binder线程选取的过程，因为这个选择过程发生在Binder Driver中，等到以后专门写Binder Driver的时候我们再展开讨论。</p>
<p>剪贴板服务对象接收到请求后，最终会调用ClipboardImpl.onTransact方法。</p>
<p><a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/services/core/java/com/android/server/clipboard/ClipboardService.java#234" target="_blank" rel="noopener">/frameworks/base/services/core/java/com/android/server/clipboard/ClipboardService.java</a></p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-number">234</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onTransact</span><span class="hljs-params">(<span class="hljs-keyword">int</span> code, Parcel data, Parcel reply, <span class="hljs-keyword">int</span> flags)</span></span></span><br><span class="line"><span class="hljs-function">235                <span class="hljs-keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"><span class="hljs-number">236</span>            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-number">237</span>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line"><span class="hljs-number">238</span>            &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line"><span class="hljs-number">239</span>                <span class="hljs-keyword">if</span> (!(e <span class="hljs-keyword">instanceof</span> SecurityException)) &#123;</span><br><span class="line"><span class="hljs-number">240</span>                    Slog.wtf(<span class="hljs-string">"clipboard"</span>, <span class="hljs-string">"Exception: "</span>, e);</span><br><span class="line"><span class="hljs-number">241</span>                &#125;</span><br><span class="line"><span class="hljs-number">242</span>                <span class="hljs-keyword">throw</span> e;</span><br><span class="line"><span class="hljs-number">243</span>            &#125;</span><br><span class="line"><span class="hljs-number">244</span></span><br><span class="line"><span class="hljs-number">245</span>        &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法接着会调用父类IClipboard.Stub的onTransact方法。</p>
<p><u><em>IClipboard.java（源码中没有，是在编译时由IClipboard.aidl文件间接生成的）</em></u></p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-number">1</span>    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onTransact</span><span class="hljs-params">(<span class="hljs-keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="hljs-keyword">int</span> flags)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="hljs-function">2    </span>&#123;</span><br><span class="line"><span class="hljs-number">3</span>      java.lang.String descriptor = DESCRIPTOR;</span><br><span class="line"><span class="hljs-number">4</span>      <span class="hljs-keyword">switch</span> (code)</span><br><span class="line"><span class="hljs-number">5</span>      &#123;</span><br><span class="line"><span class="hljs-number">6</span>        <span class="hljs-keyword">case</span> INTERFACE_TRANSACTION:</span><br><span class="line"><span class="hljs-number">7</span>        &#123;</span><br><span class="line"><span class="hljs-number">8</span>          reply.writeString(descriptor);</span><br><span class="line"><span class="hljs-number">9</span>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line"><span class="hljs-number">10</span>       &#125;</span><br><span class="line"><span class="hljs-number">11</span>       <span class="hljs-keyword">case</span> TRANSACTION_setPrimaryClip:</span><br><span class="line"><span class="hljs-number">12</span>       &#123;</span><br><span class="line"><span class="hljs-number">13</span>         data.enforceInterface(descriptor);</span><br><span class="line"><span class="hljs-number">14</span>         android.content.ClipData _arg0;</span><br><span class="line"><span class="hljs-number">15</span>         <span class="hljs-keyword">if</span> ((<span class="hljs-number">0</span>!=data.readInt())) &#123;</span><br><span class="line"><span class="hljs-number">16</span>           _arg0 = android.content.ClipData.CREATOR.createFromParcel(data);</span><br><span class="line"><span class="hljs-number">17</span>         &#125;</span><br><span class="line"><span class="hljs-number">18</span>         <span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-number">20</span>           _arg0 = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-number">21</span>         &#125;</span><br><span class="line"><span class="hljs-number">22</span>         java.lang.String _arg1;</span><br><span class="line"><span class="hljs-number">23</span>         _arg1 = data.readString();</span><br><span class="line"><span class="hljs-number">24</span>         <span class="hljs-keyword">int</span> _arg2;</span><br><span class="line"><span class="hljs-number">25</span>         _arg2 = data.readInt();</span><br><span class="line"><span class="hljs-number">26</span>         <span class="hljs-keyword">this</span>.setPrimaryClip(_arg0, _arg1, _arg2);</span><br><span class="line"><span class="hljs-number">27</span>         reply.writeNoException();</span><br><span class="line"><span class="hljs-number">28</span>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line"><span class="hljs-number">29</span>       &#125;</span><br><span class="line">      ....</span><br><span class="line">      ....</span><br><span class="line"><span class="hljs-number">131</span>  &#125;</span><br></pre></td></tr></table></figure>

<p>onTransact方法是一个大型switch-case现场，通过传输数据中的code来判断将要调用哪个方法。譬如当Client进程如下RPC时，Server进程便会走进上述代码中第11行的代码分支。</p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-number">1</span>    clipboard.setPrimaryClip(clipData);</span><br></pre></td></tr></table></figure>

<p>走进分支后，会将参数解包，并最终调用this.setPrimaryClip方法。这时回到原来的ClipboardImpl类，执行它的setPrimaryClip方法。</p>
<p><a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/services/core/java/com/android/server/clipboard/ClipboardService.java#247" target="_blank" rel="noopener">/frameworks/base/services/core/java/com/android/server/clipboard/ClipboardService.java</a></p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-number">247</span>        <span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-number">248</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPrimaryClip</span><span class="hljs-params">(ClipData clip, String callingPackage)</span> </span>&#123;</span><br><span class="line"><span class="hljs-number">249</span>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;</span><br><span class="line"><span class="hljs-number">250</span>                <span class="hljs-keyword">if</span> (clip == <span class="hljs-keyword">null</span> || clip.getItemCount() &lt;= <span class="hljs-number">0</span>) &#123;</span><br><span class="line"><span class="hljs-number">251</span>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"No items"</span>);</span><br><span class="line"><span class="hljs-number">252</span>                &#125;</span><br><span class="line"><span class="hljs-number">253</span>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line"><span class="hljs-number">254</span>                <span class="hljs-keyword">if</span> (!clipboardAccessAllowed(AppOpsManager.OP_WRITE_CLIPBOARD, callingPackage,</span><br><span class="line"><span class="hljs-number">255</span>                            callingUid)) &#123;</span><br><span class="line"><span class="hljs-number">256</span>                    <span class="hljs-keyword">return</span>;</span><br><span class="line"><span class="hljs-number">257</span>                &#125;</span><br><span class="line"><span class="hljs-number">258</span>                checkDataOwnerLocked(clip, callingUid);</span><br><span class="line"><span class="hljs-number">259</span>                setPrimaryClipInternal(clip, callingUid);</span><br><span class="line"><span class="hljs-number">260</span>            &#125;</span><br><span class="line"><span class="hljs-number">261</span>        &#125;</span><br></pre></td></tr></table></figure>

<p>当setPrimaryClip执行完毕后，（假设它有返回值）返回值将会一层层传递到native层，并最终再次通过系统调用进入Binder Driver将返回值发送回Client进程。</p>
<p>Client进程接收到返回值之后，便会结束此次RPC，然后继续执行RPC后面的代码。</p>
<p>至此，一次完整的RPC过程便结束了。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本文从应用开发者的视角出发，将Binder看作Android世界中的RPC(<code>R</code>emote <code>P</code>rocedure <code>C</code>all，远程过程调用)机制。首先介绍了RPC的通用概念，以及Android中为什么需要大量的RPC。接着进入到Binder机制内部，完整阐述了一次Binder RPC的过程，并通过“人才中心”的案例形象化地展现Binder的本质。</p>
<p>此外，就service/进程/线程之间的关系进行了明确的梳理，希望能够帮助大家扫除日常开发中的混淆和困惑。</p>

        </div>
        
        
        
    </div>
</div>








</div>
                
                    




<div class="column is-3-tablet is-3-desktop is-3-widescreen  has-order-1 column-left ">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered" style="flex-shrink: 1">
                <div>
                    
                        <img class="image is-128x128 has-mb-6" src="/images/banshan.png" alt="半山">
                    
                    
                    <p class="is-size-4 is-block">
                        半山
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        毁人二字，非惰即傲
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>中国 上海</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        文章
                    </p>
                    <p class="title has-text-weight-normal">
                        2
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        分类
                    </p>
                    <p class="title has-text-weight-normal">
                        2
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        标签
                    </p>
                    <p class="title has-text-weight-normal">
                        5
                    </p>
                </div>
            </div>
        </nav>
        
        
    </div>
</div>
    
        
    
    
        <div class="column-right-shadow is-hidden-widescreen is-sticky">
        
        </div>
    
</div>

                
            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/banshan.png" alt="半山的博客" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2019 半山&nbsp;
                Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>
                
                <br>
                <span id="busuanzi_container_site_uv">
                共<span id="busuanzi_value_site_uv">0</span>个访客
                </span>
                
                </p>
            </div>
            <div class="level-end">
            
                <div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle">
                
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Creative Commons" href="https://creativecommons.org/">
                        
                        <i class="fab fa-creative-commons"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/">
                        
                        <i class="fab fa-creative-commons-by"></i>
                        
                    </a>
                </p>
                
                </div>
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("zh-CN");</script>

<script>
var IcarusThemeSettings = {
    article: {
        highlight: {
            clipboard: true,
            fold: 'unfolded'
        }
    }
};
</script>


    <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>



    
    
    
    <script src="/js/animation.js"></script>
    

    
    
    
    <script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
    <script src="/js/gallery.js" defer></script>
    

    
    

<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


    
    
<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>

    
    

<a id="back-to-top" title="回到顶端" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>


    
    

    
    
    
    

    
    
    
    
    

    


<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>