{"pages":[{"title":"关于","text":"90后，复旦EE本硕，高通工程师。 喜欢研究Android Framework及ART虚拟机。 创建这个博客，主要是希望能够输出一些追本溯源、有价值的技术文章，间或分享一些对世事不成熟的看法。 从小到大在学校里的经历让我意识到两个问题： 不管是学生还是老师，大家通常都喜欢讨论“是什么”和“怎么做”，而很少有人去追问“为什么”。举一个简单的例子，数学里的虚数。高中上到这一课的时候，老师通常都会介绍虚数是什么，有什么运算规律，有什么快速解法等等。但似乎很少有老师会介绍“人类为什么会发明虚数”、“虚数最初用于解决什么问题”以及“虚数出现的历史背景”之类的问题。 上了大学后选择了电子工程这个专业，惊奇地发现即便是在中国排名较为靠前的高校里，理工科的学生也依然很少读课外书。有些同学的书架上，甚至连一本非专业的书籍也找不出来。 这两个现象可能是我的过分解读，但我更愿意将它作为一面镜子来时刻自省，所以凡是讨论技术，就多问几个为什么；若是不讨论技术，也要可以三言两语说上几句。","link":"/about/index.html"}],"posts":[{"title":"Binder概述","text":"本文分析基于Android P(9.0) 源码 在编程的世界中，不同进程间的通信、协同、合作随处可见。很多时候，人们习惯用IPC(Inter Process Communication，跨进程通信)来称呼它们。譬如Binder在多数情况下也被称为Android世界中的IPC机制。但如果以应用开发者的视角来看，Binder也可以称为Android世界中的RPC(Remote Procedure Call，远程过程调用)机制。 IPC(Inter Process Communication，跨进程通信) 泛指一切用于进程间传递信息量（传输数据只是传递信息量的一个子集）的方式，譬如socket/pipe/FIFO/semaphore等。这些名称表征的是信息传输的具体方式，而不涉及信息的处理和加工。 RPC(Remote Procedure Call，远程过程调用) 一种建构于IPC基础之上的方法调用。对于客户端而言，它可以感知到的仅仅是方法调用和获取返回值两个过程。然而实际上这个方法内部完成了客户端参数打包，数据传输，服务端数据解包，服务端数据处理，服务端结果返回等一系列中间过程。只不过这些过程对于客户端而言都是“透明”的。所以可以说IPC只是RPC中的一个环节，除此之外，RPC还包含数据打包，解包以及处理的过程，它们可以统称为信息的处理和加工过程。 1. Android中为什么需要大量的RPC？下面举一个剪贴板的例子，来直观地呈现RPC的内涵。 通过如下代码，我们可以将一段文字复制到剪贴板。在执行第8行代码后，便可以将文本复制到剪贴板上。这里事先透露下，第8行代码本质上是一个RPC。 1 // 获取系统剪贴板2 ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);3 4 // 创建一个剪贴数据集，包含一个普通文本数据条目（需要复制的数据）5 ClipData clipData = ClipData.newPlainText(null, \"需要复制的文本数据\");6 7 // 把数据集设置（复制）到剪贴板8 clipboard.setPrimaryClip(clipData); 那么RPC和非RPC的差异到底在什么地方呢？下面用一幅图来解释这个问题。 在RPC的过程中，进程B来进行真正的方法执行，相当于为进程A提供了某种服务，因此进程B在RPC的过程中也可以称为Server进程，进程A对应地可以称为Client进程。 接着再来讨论一个问题，为什么Android中需要使用大量的RPC？将RPC换成本地方法不可以么？ 答案是不可以。因为Android本身是一个中心化管理的系统，RPC可以保证一个Server进程管理众多Client进程的调用请求，且能够实现系统状态的统一管理。举个例子，如果我们在一个App中将一段文字复制到剪贴板，假设这个复制过程是调用本地方法完成的（复制状态仅局限于App进程），那么离开这个App后新的剪贴板就不会再有这段文字。反之，如果我们采用RPC来完成复制，那么最终的文字将传递给了Server进程。而Server进程通常是常驻内存，所以即便我们离开App，剪贴板上的文字也依然存在，保证它可以被粘贴到其他App中。在Android中，大量的系统服务都是在system_server进程中完成各自功能的，譬如ActivityManagerService。 2. Binder世界里的service到底是什么概念？在进行具体阐述之前，我们先要做一个限定。以下所讨论的service是类似于ActivityManagerService、PackageManagerService、WindowManagerService等一系列的服务，它们是Binder语义下的service，而不是Android四大组件中的service。 不过“服务(service)”到底是什么意思呢？它是一类近似功能的统称。譬如“商人的服务”，就可以包含“购买薯片”、“购买可乐”、“购买沙发”、“购买电视”等一系列功能。ActivityManagerService是一个类，它里面定义实现了很多方法，详细描述了每一项功能应该来如何提供。但是它只是一个模板，是无法实际提供服务的。真正提供服务的是ActivityManagerService实例化出来的对象。在Android中，ActivityManagerService只会实例化出来一个对象，而它就是真正为应用提供AMS服务的人。 /frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 2877 public static final class Lifecycle extends SystemService {2878 private final ActivityManagerService mService;28792880 public Lifecycle(Context context) {2881 super(context);2882 mService = new ActivityManagerService(context);2883 } 这个对象是在system_server进程启动的时候创建出来的，具体是在ActivityManagerService.Lifecycle的构造过程中完成。 /frameworks/base/services/java/com/android/server/SystemServer.java 559 mActivityManagerService = mSystemServiceManager.startService(560 ActivityManagerService.Lifecycle.class).getService(); 由于整个系统中，ActivityManagerService实例化的对象只有一个，所以将它称为“AMS”、“AMS实例化的对象”都无所谓。这就好比整个饭店就一个厨师，你叫他“厨师”还是“王厨师”都不影响理解。 2.1 service与进程/线程的关系如果将service看作一个可以提供服务的Java对象，那么这个问题将会迎刃而解。 Java对象是存放在堆上的，因此可以在同一个进程里的不同线程间共享，所以service（准确来说应该是service对象的方法）也可以在不同的线程里运行。 另外，一个进程里可以构造出成千上万的对象，因此一个进程里也可以存在成千上万的service。而且同一个类型的service也可以存在很多个，譬如我们可以在system_server进程中同时构造ActivityManagerService对象A/B/C，三个AMS对象表示三个可以提供服务的实体，这就好比饭店里现在有了三个厨师，你可以跟其中任何一个请求服务。当然，在实际的Android系统中，同一个类型的service多数情况下只有一个对象。但现实情况不存在并不代表理论上不可实现，所以理论上同一个类型的service可以在一个进程中存在多个对象。 3. RPC的内部是如何构成的？本文开篇提到，对于客户端而言，它可以感知到的仅仅是方法调用和获取返回值两个过程。那么具体到剪贴板这个例子来的话，对于Android应用的开发者而言，他感知到的只有下面两件事： 对于Android应用的开发者而言，他感知到的只有下面两件事： 我调用了clipboard.setPrimaryClip()方法 剪贴板上出现了我想要复制的文字 在这个过程中，应用开发者根本感知不到这是一次跨进程的调用，也感受不到调用背后的数据传输。RPC机制将这一切都封装了起来，因此开发者可以天真地认为所有这一切都发生在应用进程。而这也正是系统设计者希望给开发者带去的便利和简化，既是理解上的简化，也是使用上的简化。 不过一个有追求的开发者通常只会选择使用上的简化，而不会局限在理解上的简化。所以下面我将用一种颇具趣味性的方式来继续阐述。 3.1 “人才中心”的例子所有的算法和设计模式都是从社会生活中抽象提炼出来的。所以本着“从群众中来，到群众中去”的原则，我们赋予冰冷的源码以生命，从社会生活的角度来理解RPC，来理解Binder。 前几年，城市里面新建了几座各具特色的人才中心，每一个中心都汇聚了来自五湖四海的奇人异士。他们中有手艺精湛的厨师，有投机倒把的商人，有妙笔生花的作家，还有勤勤恳恳的果农。人才中心有很多电话间，方便他们打电话的时候互不干扰。有一天，小明想从人才中心A里面的贾商人那里买一个键盘，于是拨通了A大厦的电话…… 上面的例子完全可以映射成一次RPC。人才中心表示进程，电话间表示线程，职业表示service所属的类，贾商人表示一个具体的提供service的对象，买键盘表示服务的方法，打电话表示数据传输的方式，小明表示Client进程。 小明打电话给人才中心A：Client进程跟Server进程A通信，除此之外，Client进程也可以跟Server进程B/C/D通信。 小明想找贾商人买一个键盘（伪代码表示如下）： 第1行表示贾商人出现了，第2行表示他在人才登记处（非人才中心）将自己的名字登记在册。 1 Merchant jia = new Merchant(\"Jia\");2 ServiceManager.addService(\"MerchantJia\", jia); 下面的代码表示小明打电话购买键盘的过程。第1行表示他从人才登记处要到了贾商人的号码，第2行表示他打电话给贾商人提出购买键盘的请求。贾商人接到请求后，立马发货，返回值result表明小明收到了键盘。 1 IMerchant merchantJia = IMerchant.Stub.asInterface(ServiceManager.getService(\"MerchantJia\"));2 Keyboard result = merchantJia.buyKeyboard(); 那如果小明不想找贾商人买了，换成甄商人会怎么样？ 甄商人在人才登记处（非人才中心）登记： 1 Merchant zhen = new Merchant(\"Zhen\");2 ServiceManager.addService(\"MerchantZhen\", zhen); 小明打电话购买键盘： 1 IMerchant merchantZhen = IMerchant.Stub.asInterface(ServiceManager.getService(\"MerchantZhen\"));2 Keyboard result = merchantZhen.buyKeyboard(); 不管是贾商人还是甄商人，他们都是商人，因此都是由Merchant类实例化而来。因此，职业“商人”就映射为了“Merchant”类，而类实例化出来的对象就是具体提供service的对象（贾商人和甄商人），表示提供某一类服务的实体。 贾商人去电话间接电话： 人才中心接线员收到小明的电话，说要找贾商人，于是给贾商人分配了电话间D。之所以分配D，是因为A/B/C三个电话间现在都有人在使用。类比回源码，人才中心表示Server进程， 电话间表示线程。 人才中心接收到小明的请求，表示Server进程接收到Client进程的数据。之后便决定将它交由贾商人处理，表示Server进程会将Client传输过来的数据交由MerchantJia这个对象来处理。接着是分配电话间，A/B/C三个电话间正在被使用，表示目前有三个Binder线程正在处理其他请求。于是最终将电话间D分配给贾商人，表示service的方法接下来将运行在线程D中。 3.2 剪贴板的例子接下来以上文中剪贴板复制文本的代码为样本，来阐述一次RPC中所涵盖的具体过程。 1 // 获取系统剪贴板2 ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);3 4 // 创建一个剪贴数据集，包含一个普通文本数据条目（需要复制的数据）5 ClipData clipData = ClipData.newPlainText(null, \"需要复制的文本数据\");6 7 // 把数据集设置（复制）到剪贴板8 clipboard.setPrimaryClip(clipData); 3.2.1 service对象的创建过程剪贴板服务对象位于system_server进程，而它的代理对象则可以分布在所有需要此项服务的App进程中。 因此，剪贴板服务对象的创建也发生在system_server进程（Server进程）。它是ClipboardImpl类型，这个类里面的方法就是剪贴板服务的具体实现。 /frameworks/base/services/core/java/com/android/server/clipboard/ClipboardService.java 232 private class ClipboardImpl extends IClipboard.Stub {233 @Override234 public boolean onTransact(int code, Parcel data, Parcel reply, int flags)235 throws RemoteException {236 try {237 return super.onTransact(code, data, reply, flags);238 } catch (RuntimeException e) {239 if (!(e instanceof SecurityException)) {240 Slog.wtf(\"clipboard\", \"Exception: \", e);241 }242 throw e;243 }244245 }246247 @Override248 public void setPrimaryClip(ClipData clip, String callingPackage) {249 synchronized (this) {250 if (clip == null || clip.getItemCount() &lt;= 0) {251 throw new IllegalArgumentException(\"No items\");252 }253 final int callingUid = Binder.getCallingUid();254 if (!clipboardAccessAllowed(AppOpsManager.OP_WRITE_CLIPBOARD, callingPackage,255 callingUid)) {256 return;257 }258 checkDataOwnerLocked(clip, callingUid);259 setPrimaryClipInternal(clip, callingUid);260 }261 } 剪贴板服务对象是在ClipboardService.onStart方法中创建并注册到ServiceManager中的，整个过程都发生在system_server进程的启动过程中。 /frameworks/base/services/core/java/com/android/server/clipboard/ClipboardService.java 192 @Override193 public void onStart() {194 publishBinderService(Context.CLIPBOARD_SERVICE, new ClipboardImpl());195 } /frameworks/base/services/java/com/android/server/SystemServer.java 1064 traceBeginAndSlog(\"StartClipboardService\");1065 mSystemServiceManager.startService(ClipboardService.class);1066 traceEnd(); 3.2.2 寻找service对象的代理对象1 // 获取系统剪贴板2 ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);3 4 // 创建一个剪贴数据集，包含一个普通文本数据条目（需要复制的数据）5 ClipData clipData = ClipData.newPlainText(null, \"需要复制的文本数据\");6 7 // 把数据集设置（复制）到剪贴板8 clipboard.setPrimaryClip(clipData); 寻找代理对象的过程发生在Client进程中。上面第2行的clipboard对象是一层封装，其内部就是剪贴板服务对象的代理对象（原谅我表述得这么拗口，但为了含义的准确表达，牺牲一些语言的美感也无可厚非）。 /frameworks/base/core/java/android/app/ContextImpl.java 1719 @Override1720 public Object getSystemService(String name) {1721 return SystemServiceRegistry.getSystemService(this, name);1722 } /frameworks/base/core/java/android/app/SystemServiceRegistry.java 1012 public static Object getSystemService(ContextImpl ctx, String name) {1013 ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);1014 return fetcher != null ? fetcher.getService(ctx) : null;1015 } /frameworks/base/core/java/android/app/SystemServiceRegistry.java 178 private static final HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS =179 new HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;(); /frameworks/base/core/java/android/app/SystemServiceRegistry.java 261 registerService(Context.CLIPBOARD_SERVICE, ClipboardManager.class,262 new CachedServiceFetcher&lt;ClipboardManager&gt;() {263 @Override264 public ClipboardManager createService(ContextImpl ctx) throws ServiceNotFoundException {265 return new ClipboardManager(ctx.getOuterContext(),266 ctx.mMainThread.getHandler());267 }}); SYSTEM_SERVICE_FETCHERS是一个HashMap，它以键值对的方式存储了很多系统服务对象的代理对象（或其wrapper对象）。对剪贴板而言，getSystemService方法最终会创建一个ClipboardManager对象并返回。 /frameworks/base/core/java/android/content/ClipboardManager.java 85 public ClipboardManager(Context context, Handler handler) throws ServiceNotFoundException {86 mContext = context;87 mHandler = handler;88 mService = IClipboard.Stub.asInterface(89 ServiceManager.getServiceOrThrow(Context.CLIPBOARD_SERVICE));90 } ClipboardManager的构造方法里，88行尤为关键。首先根据字符串”clipboard”去ServiceManger中找到剪贴板服务对象的代理对象，此时获得的代理对象只具有跨进程通信的能力。接着通过asInterface为这个代理对象赋予剪贴板的能力。 /frameworks/base/core/java/android/content/Context.java 3727 public static final String CLIPBOARD_SERVICE = \"clipboard\"; 对于Java而言，接口相当于一种能力。在Binder的世界中，一个服务对象的代理对象通常封装了特定的服务接口，譬如剪贴板就是IClipboard，表示该对象具有剪贴板服务所能提供的诸多能力，譬如复制文字、粘贴文字等。另外，该代理对象内部有个字段封装了IBinder接口，表示该字段具有跨进程通信的能力，它在每次IPC的过程中都会发挥作用。 IClipboard.Stub是AIDL文件自动生成的一个类，在最终生成的文件中还有一个类是IClipboard.Stub.Proxy，它们是Binder原生类的一层封装。相较于Binder原生类，它们多了一层数据打包和解包的过程。 IClipboard.java（源码中没有，是在编译时由IClipboard.aidl文件间接生成的） 1 /** Local-side IPC implementation stub class. */2 public static abstract class Stub extends android.os.Binder implements android.content.IClipboard 1 private static class Proxy implements android.content.IClipboard IClipboard.Stub.asInterface方法给原本只具有IBinder（跨进程通信）能力的对象赋予IClipboard（剪贴板）能力。这样一来，得到的代理对象就同时兼具了跨进程通信的能力和剪贴板的能力。跨进程通信的能力对开发者而言是透明的，而剪贴板的能力才是他们真正关心的。 3.2.3 通过代理对象进行RPC最终调用clipboard.setPrimaryClip(clipData)往剪贴板上写数据时，实际底层调用的却是mService.setPrimaryClip方法，mService就是刚刚通过asInterface得到的代理对象。 /frameworks/base/core/java/android/content/ClipboardManager.java 100 public void setPrimaryClip(@NonNull ClipData clip) {101 try {102 Preconditions.checkNotNull(clip);103 clip.prepareToLeaveProcess(true);104 mService.setPrimaryClip(clip, mContext.getOpPackageName());105 } catch (RemoteException e) {106 throw e.rethrowFromSystemServer();107 }108 } mService.setPrimaryClip方法最终调用的是IClipboard.Stub.Proxy.setPrimaryClip方法，将参数打包放入 _data中，并从 _reply中解包读出Server端传输过来的返回值（这个用来示例的方法中没有返回值）。而真正的跨进程传输是通过下面第16行完成的。mRemote的类型为android.os.IBinder，表明它具有跨进程传输的能力。调用它的transact方法表示将打包后的参数发送给Server进程。 IClipboard.java（源码中没有，是在编译时由IClipboard.aidl文件间接生成的） 1 @Override public void setPrimaryClip(android.content.ClipData clip, java.lang.String callingPackage, int userId) throws android.os.RemoteException2 {3 android.os.Parcel _data = android.os.Parcel.obtain();4 android.os.Parcel _reply = android.os.Parcel.obtain();5 try {6 _data.writeInterfaceToken(DESCRIPTOR);7 if ((clip!=null)) {8 _data.writeInt(1);9 clip.writeToParcel(_data, 0);10 }11 else {12 _data.writeInt(0);13 }14 _data.writeString(callingPackage);15 _data.writeInt(userId);16 boolean _status = mRemote.transact(Stub.TRANSACTION_setPrimaryClip, _data, _reply, 0);17 if (!_status &amp;&amp; getDefaultImpl() != null) {18 getDefaultImpl().setPrimaryClip(clip, callingPackage, userId);19 return;20 }21 _reply.readException();22 }23 finally {24 _reply.recycle();25 _data.recycle();26 }27 } 数据传输的过程最终由Binder Driver来负责，所以上述的transact方法最终会通过ioctl的系统调用进入到内核空间，通过一系列的驱动函数将数据发送给Server进程。 3.2.4 服务对象处理接收到的请求Server进程接收到Client进程传输来的参数数据后，就会开始实际的处理。这里我们跳过Binder线程选取的过程，因为这个选择过程发生在Binder Driver中，等到以后专门写Binder Driver的时候我们再展开讨论。 剪贴板服务对象接收到请求后，最终会调用ClipboardImpl.onTransact方法。 /frameworks/base/services/core/java/com/android/server/clipboard/ClipboardService.java 234 public boolean onTransact(int code, Parcel data, Parcel reply, int flags)235 throws RemoteException {236 try {237 return super.onTransact(code, data, reply, flags);238 } catch (RuntimeException e) {239 if (!(e instanceof SecurityException)) {240 Slog.wtf(\"clipboard\", \"Exception: \", e);241 }242 throw e;243 }244245 } 这个方法接着会调用父类IClipboard.Stub的onTransact方法。 IClipboard.java（源码中没有，是在编译时由IClipboard.aidl文件间接生成的） 1 @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException2 {3 java.lang.String descriptor = DESCRIPTOR;4 switch (code)5 {6 case INTERFACE_TRANSACTION:7 {8 reply.writeString(descriptor);9 return true;10 }11 case TRANSACTION_setPrimaryClip:12 {13 data.enforceInterface(descriptor);14 android.content.ClipData _arg0;15 if ((0!=data.readInt())) {16 _arg0 = android.content.ClipData.CREATOR.createFromParcel(data);17 }18 else {20 _arg0 = null;21 }22 java.lang.String _arg1;23 _arg1 = data.readString();24 int _arg2;25 _arg2 = data.readInt();26 this.setPrimaryClip(_arg0, _arg1, _arg2);27 reply.writeNoException();28 return true;29 } .... ....131 } onTransact方法是一个大型switch-case现场，通过传输数据中的code来判断将要调用哪个方法。譬如当Client进程如下RPC时，Server进程便会走进上述代码中第11行的代码分支。 1 clipboard.setPrimaryClip(clipData); 走进分支后，会将参数解包，并最终调用this.setPrimaryClip方法。这时回到原来的ClipboardImpl类，执行它的setPrimaryClip方法。 /frameworks/base/services/core/java/com/android/server/clipboard/ClipboardService.java 247 @Override248 public void setPrimaryClip(ClipData clip, String callingPackage) {249 synchronized (this) {250 if (clip == null || clip.getItemCount() &lt;= 0) {251 throw new IllegalArgumentException(\"No items\");252 }253 final int callingUid = Binder.getCallingUid();254 if (!clipboardAccessAllowed(AppOpsManager.OP_WRITE_CLIPBOARD, callingPackage,255 callingUid)) {256 return;257 }258 checkDataOwnerLocked(clip, callingUid);259 setPrimaryClipInternal(clip, callingUid);260 }261 } 当setPrimaryClip执行完毕后，（假设它有返回值）返回值将会一层层传递到native层，并最终再次通过系统调用进入Binder Driver将返回值发送回Client进程。 Client进程接收到返回值之后，便会结束此次RPC，然后继续执行RPC后面的代码。 至此，一次完整的RPC过程便结束了。 4. 总结本文从应用开发者的视角出发，将Binder看作Android世界中的RPC(Remote Procedure Call，远程过程调用)机制。首先介绍了RPC的通用概念，以及Android中为什么需要大量的RPC。接着进入到Binder机制内部，完整阐述了一次Binder RPC的过程，并通过“人才中心”的案例形象化地展现Binder的本质。 此外，就service/进程/线程之间的关系进行了明确的梳理，希望能够帮助大家扫除日常开发中的混淆和困惑。","link":"/Binder概述/"},{"title":"Android消息机制","text":"本文分析基于Android P(9.0) 源码 1 概述消息机制是Android中重要的线程间通信手段。 它的存在可以让一个线程通知另一个线程去工作。那么一个线程为什么会有让另一个线程工作的需求呢？ 可以看一个常见的应用场景——UI更新。Google官方有一句话解释了UI更新的规则：The Android UI toolkit is not thread-safe and the view must always be manipulated on the UI thread。 因为UI更新并不是线程安全的，所以Android为了规避开发者可能的不安全操作，干脆将所有UI更新都放在了主线程中进行。在这种场景下，就会出现其他线程请求主线程来帮忙更新UI的需求。 除了UI更新，某些设计模式的实现也离不开消息机制。 下图便是消息机制最基本的工作方式。A线程发送消息到B线程的消息队列中，B线程不断从消息队列中取出新的消息进行处理。 线程A在这里表现的就像是一个甩手掌柜，只负责发送消息，却从不干活。而线程B就像是一个苦力，不断地处理到来的消息。 2 详细过程下图便是消息机制的详细过程，主要分为两个部分： 消息发送过程 消息处理过程 消息通过Handler发送到另一个线程的MessageQueue中。另一个线程通过Looper不断轮询消息队列，取出其中的消息，并交给当初发送它的Handler进行处理。 上述详细过程有一个前提假设，也即线程B中存在Looper和MessageQueue。事实上，这两样东西并不是天生存在的。所以真正完整的详细过程包含以下三个部分： 消息队列准备过程 消息发送过程 消息处理过程 2.1 消息队列准备过程在Android应用中，主线程自带Looper和MessageQueue，其他线程如果想具备消息机制的功能，则必须首先调用Looper.prepare()。 主线程为什么会自带Looper和MessageQueue呢？ 所有Android应用的主线程都对应一个ActivityThread，正是由于所有Activity的回调方法都运行在主线程，所以Google便用ActivityThread来对应主线程。 ActivityThread的main方法是每个Android应用启动时的入口。通过6642行代码可知，主线程并非自带了Looper和MessageQueue，而是在ActivityThread的main方法中提前为我们创建好了而已。6642行创建了主线程的Looper和MessageQueue（下文有详述），6669行便开始了Looper的循环工作：不断从MessageQueue中取出消息并执行，消息队列为空时就将所在线程挂起休息，有新的消息到来时再起来继续工作。周而复始，永不停歇。 以上就是Android主线程的基本工作模型。至于我们所熟知的onCreate、onDestroy，其实背后也都是消息机制在起作用（当然还有Binder的身影）。 /frameworks/base/core/java/android/app/ActivityThread.java 6623 public static void main(String[] args) {6624 Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"ActivityThreadMain\");66256626 // CloseGuard defaults to true and can be quite spammy. We6627 // disable it here, but selectively enable it later (via6628 // StrictMode) on debug builds, but using DropBox, not logs.6629 CloseGuard.setEnabled(false);66306631 Environment.initForCurrentUser();66326633 // Set the reporter for event logging in libcore6634 EventLogger.setReporter(new EventLoggingReporter());66356636 // Make sure TrustedCertificateStore looks in the right place for CA certificates6637 final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());6638 TrustedCertificateStore.setDefaultUserDirectory(configDir);66396640 Process.setArgV0(\"&lt;pre-initialized&gt;\");66416642 Looper.prepareMainLooper();66436644 // Find the value for {@link #PROC_START_SEQ_IDENT} if provided on the command line.6645 // It will be in the format \"seq=114\"6646 long startSeq = 0;6647 if (args != null) {6648 for (int i = args.length - 1; i &gt;= 0; --i) {6649 if (args[i] != null &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) {6650 startSeq = Long.parseLong(6651 args[i].substring(PROC_START_SEQ_IDENT.length()));6652 }6653 }6654 }6655 ActivityThread thread = new ActivityThread();6656 thread.attach(false, startSeq);66576658 if (sMainThreadHandler == null) {6659 sMainThreadHandler = thread.getHandler();6660 }66616662 if (false) {6663 Looper.myLooper().setMessageLogging(new6664 LogPrinter(Log.DEBUG, \"ActivityThread\"));6665 }66666667 // End of event ActivityThreadMain.6668 Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);6669 Looper.loop();66706671 throw new RuntimeException(\"Main thread loop unexpectedly exited\");6672 } Looper.prepareMainLooper是一个静态方法，它的作用是为主线程创建一个Looper和MessageQueue。其最终调用了prepare方法，创建了一个新的Looper并将它写入sThreadLocal字段。 sThreadLocal字段是一个静态变量，按照常理它应该在内存中独一份，且各个线程均可访问的。但这里sThreadLocal利用了TLS（ThreadLocalStorage）的机制，每个线程访问到的sThreadLocal是相互独立的，并不是同一个。所以，主线程调用prepareMainLooper方法，相当于创建了一个线程独有的Looper，并且将这个Looper赋值给名为sMainLooper的静态变量（方便其他线程获取主线程的Looper）。 /frameworks/base/core/java/android/os/Looper.java 114 public static void prepareMainLooper() {115 prepare(false);116 synchronized (Looper.class) {117 if (sMainLooper != null) {118 throw new IllegalStateException(\"The main Looper has already been prepared.\");119 }120 sMainLooper = myLooper();121 }122 } /frameworks/base/core/java/android/os/Looper.java 97 public static void prepare() {98 prepare(true);99 }100101 private static void prepare(boolean quitAllowed) {102 if (sThreadLocal.get() != null) {103 throw new RuntimeException(\"Only one Looper may be created per thread\");104 }105 sThreadLocal.set(new Looper(quitAllowed));106 } Looper的构造方法中会创建一个MessageQueue，所以调用Looper.prepare方法便会创建与线程唯一对应的Looper和MessageQueue。 /frameworks/base/core/java/android/os/Looper.java 267 private Looper(boolean quitAllowed) {268 mQueue = new MessageQueue(quitAllowed);269 mThread = Thread.currentThread();270 } MessageQueue的构造方法如下，它会调用nativeInit方法在native层做一些初始化的工作。 /frameworks/base/core/java/android/os/MessageQueue.java 70 MessageQueue(boolean quitAllowed) {71 mQuitAllowed = quitAllowed;72 mPtr = nativeInit();73 } 63 private native static long nativeInit(); nativeInit对应的JNI方法为android_os_MessageQueue_nativeInit，其中创建了一个NativeMessageQueue对象，并将该对象的指针转化为long型传递给java层。在Android的世界中，存在大量java层对象和native层对象一一映射的关系，通常都是在java层对象中设立一个long型的字段，用于记录native对象的指针值。 /frameworks/base/core/jni/android_os_MessageQueue.cpp 172static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) {173 NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();174 if (!nativeMessageQueue) {175 jniThrowRuntimeException(env, \"Unable to allocate native queue\");176 return 0;177 }178179 nativeMessageQueue-&gt;incStrong(env);180 return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);181} 在NativeMessageQueue的构造函数中创建一个native层的Looper，并通过TLS的机制和线程绑定。 /frameworks/base/core/jni/android_os_MessageQueue.cpp 78NativeMessageQueue::NativeMessageQueue() :79 mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) {80 mLooper = Looper::getForThread();81 if (mLooper == NULL) {82 mLooper = new Looper(false);83 Looper::setForThread(mLooper);84 }85} 在native层Looper的构造过程中，67行的代码非常关键。它用于mWakeEventFd的初始化，创建出来的eventfd将会在rebuildEpollLocked函数中被epoll监听（151行）。Epoll机制是Linux内核中一种事件触发的机制，可以同时监听多个文件描述符。在调用epoll_wait将线程挂起的时候，如果有被监测的事件产生，则线程从挂起状态恢复，重新恢复运行。这其实是一种中断式的wait/notify机制。如果想了解这个机制的详细内容，可以参考这两篇博客：博客1 和博客2。博客1中对epoll的基本概念讲述较多，博客2对epoll中的Level Trigger和Edge Trigger讲的非常清楚。 我们以149行到151行的代码为例，EPOLLIN表示监测mWakeEventFd上的可读事件，当该线程调用epoll_wait时，如果mWakeEventFd上有可读事件，则线程直接返回，否则挂起。在该线程挂起的时候，如果有其他线程往mWakeEventFd上写入新的数据，则该线程会接收到事件，并从挂起状态恢复为运行状态。 /system/core/libutils/Looper.cpp 63Looper::Looper(bool allowNonCallbacks) :64 mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false),65 mPolling(false), mEpollFd(-1), mEpollRebuildRequired(false),66 mNextRequestSeq(0), mResponseIndex(0), mNextMessageUptime(LLONG_MAX) {67 mWakeEventFd = eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC);68 LOG_ALWAYS_FATAL_IF(mWakeEventFd &lt; 0, \"Could not make wake event fd: %s\",69 strerror(errno));7071 AutoMutex _l(mLock);72 rebuildEpollLocked();73} /system/core/libutils/Looper.cpp 134void Looper::rebuildEpollLocked() {135 // Close old epoll instance if we have one.136 if (mEpollFd &gt;= 0) {137#if DEBUG_CALLBACKS138 ALOGD(\"%p ~ rebuildEpollLocked - rebuilding epoll set\", this);139#endif140 close(mEpollFd);141 }142143 // Allocate the new epoll instance and register the wake pipe.144 mEpollFd = epoll_create(EPOLL_SIZE_HINT);145 LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, \"Could not create epoll instance: %s\", strerror(errno));146147 struct epoll_event eventItem;148 memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union149 eventItem.events = EPOLLIN;150 eventItem.data.fd = mWakeEventFd;151 int result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, &amp; eventItem);152 LOG_ALWAYS_FATAL_IF(result != 0, \"Could not add wake event fd to epoll instance: %s\",153 strerror(errno));154155 for (size_t i = 0; i &lt; mRequests.size(); i++) {156 const Request&amp; request = mRequests.valueAt(i);157 struct epoll_event eventItem;158 request.initEventItem(&amp;eventItem);159160 int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, request.fd, &amp; eventItem);161 if (epollResult &lt; 0) {162 ALOGE(\"Error adding epoll events for fd %d while rebuilding epoll set: %s\",163 request.fd, strerror(errno));164 }165 }166} 综上所述，一个可以处理消息的线程，必然会有一个唯一的Looper和唯一的MessageQueue。 2.2 消息发送过程消息通过Handler进行发送。 通过调用Handler类的sendMessage方法，我们可以发送一个消息。sendMessage最终调用的是sendMessageAtTime方法。参数uptimeMillis表示希望消息发送的时间点距离开机时间点的毫秒数，譬如手机15:00:00开机，消息发送者希望这条消息15:00:01准时发送，那么传入的uptimeMillis就是1000。 /frameworks/base/core/java/android/os/Handler.java 602 public final boolean sendMessage(Message msg)603 {604 return sendMessageDelayed(msg, 0);605 } 662 public final boolean sendMessageDelayed(Message msg, long delayMillis)663 {664 if (delayMillis &lt; 0) {665 delayMillis = 0;666 }667 return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);668 } 689 public boolean sendMessageAtTime(Message msg, long uptimeMillis) {690 MessageQueue queue = mQueue;691 if (queue == null) {692 RuntimeException e = new RuntimeException(693 this + \" sendMessageAtTime() called with no mQueue\");694 Log.w(\"Looper\", e.getMessage(), e);695 return false;696 }697 return enqueueMessage(queue, msg, uptimeMillis);698 } sendMessageAtTime方法取出Handler的mQueue字段，并调用enqueueMessage方法。enqueueMessage的作用就是将消息加入到消息队列中。首先，将消息的target字段设置为发送时的Handler，表明这个消息被接收后依然由此Handler进行处理。其后根据Handler是否异步来决定发送的消息是否异步。最后调用MessageQueue的enqueueMessage方法。 /frameworks/base/core/java/android/os/Handler.java 740 private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {741 msg.target = this;742 if (mAsynchronous) {743 msg.setAsynchronous(true);744 }745 return queue.enqueueMessage(msg, uptimeMillis);746 } 745行的queue是从Handler的sendMessageAtTime方法中传递过来的，它是Handler对象的mQueue字段，在Handler对象的构造方法中被赋值。为了搞清楚mQueue的来及，我们有必要看一看Handler的构造方法。 2.2.1 消息被发送到哪个线程？Handler的构造方法被重载了很多个，但底层其实都是这两个： /frameworks/base/core/java/android/os/Handler.java 192 public Handler(Callback callback, boolean async) {193 if (FIND_POTENTIAL_LEAKS) {194 final Class&lt;? extends Handler&gt; klass = getClass();195 if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;196 (klass.getModifiers() &amp; Modifier.STATIC) == 0) {197 Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" +198 klass.getCanonicalName());199 }200 }201202 mLooper = Looper.myLooper();203 if (mLooper == null) {204 throw new RuntimeException(205 \"Can't create handler inside thread \" + Thread.currentThread()206 + \" that has not called Looper.prepare()\");207 }208 mQueue = mLooper.mQueue;209 mCallback = callback;210 mAsynchronous = async;211 } 232 public Handler(Looper looper, Callback callback, boolean async) {233 mLooper = looper;234 mQueue = looper.mQueue;235 mCallback = callback;236 mAsynchronous = async;237 } 二者最大的区别就在于，一个传入了Looper，另一个没有传入Looper。 传入Looper的话，Handler对象的mQueue就等于looper.mQueue。假设Handler对象在线程A中创建，其构造时传入的是线程B的Looper，那么通过这个Handler发送的消息就将由线程B来处理。 没有传入Looper的话，Handler对象的mQueue就等于其创建线程的Looper。依然假设Handler对象在线程A中创建，此时构造Handler时没有传入Looper，那么通过这个Handler发送的消息就将由线程A来处理。 请仔细体会上述两种情况的区别。 针对没有传入Looper的情况，这里还要多提几句。Handler对象创建之后，由于它存在于Java堆上，所以可以被任何线程访问、使用。任何线程通过它发送的消息，最终都将汇总到其创建线程的MessageQueue中，包括在它的创建线程中发送消息。 下面看看MessageQueue的enqueueMessage方法做了哪些工作。 /frameworks/base/core/java/android/os/MessageQueue.java 536 boolean enqueueMessage(Message msg, long when) {537 if (msg.target == null) {538 throw new IllegalArgumentException(\"Message must have a target.\");539 }540 if (msg.isInUse()) {541 throw new IllegalStateException(msg + \" This message is already in use.\");542 }543544 synchronized (this) {545 if (mQuitting) {546 IllegalStateException e = new IllegalStateException(547 msg.target + \" sending message to a Handler on a dead thread\");548 Log.w(TAG, e.getMessage(), e);549 msg.recycle();550 return false;551 }552553 msg.markInUse();554 msg.when = when;555 Message p = mMessages;556 boolean needWake;557 if (p == null || when == 0 || when &lt; p.when) {558 // New head, wake up the event queue if blocked.559 msg.next = p;560 mMessages = msg;561 needWake = mBlocked;562 } else {563 // Inserted within the middle of the queue. Usually we don't have to wake564 // up the event queue unless there is a barrier at the head of the queue565 // and the message is the earliest asynchronous message in the queue.566 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();567 Message prev;568 for (;;) {569 prev = p;570 p = p.next;571 if (p == null || when &lt; p.when) {572 break;573 }574 if (needWake &amp;&amp; p.isAsynchronous()) {575 needWake = false;576 }577 }578 msg.next = p; // invariant: p == prev.next579 prev.next = msg;580 }581582 // We can assume mPtr != 0 because mQuitting is false.583 if (needWake) {584 nativeWake(mPtr);585 }586 }587 return true;588 } 跳过enqueueMessage方法中的异常判断，其核心的作用只有一个：将新消息加入MessageQueue中的消息链表中。MessageQueue中的Message通过链表的方式进行管理，其中的消息按照发送时间的先后顺序排列。在管理链表的过程中，只需持有头部对象就可以遍历所有的对象。因此MessageQueue只用了一个字段（mMessages）来记录消息链表的头部消息。 2.2.2 消息应该被插入到链表的什么位置？557行和562行分别表示对新消息的两种处理方式，第一种是将新消息插入到链表头部，第二种是将新消息插入到链表中间（或尾部）。 先分析插入链表头部的情况。 p == null 表示MessageQueue的消息链表为空，也即所有消息发送完毕，新加入的消息理所应当插入到头部。 when == 0表示消息通过sendMessageAtTime方法发送，且传入的uptime为0，此类消息优先级最高，不管消息链表中是何种情况，新加入的消息都要插入到头部。 when &lt; p.when表示新消息预设的发送时间要早于现有头部消息的发送时间，根据时间越早越靠前的原则，新加入的消息要插入到头部。 除了插入到头部的三种情况外，其他情况下消息都将插入到链表中间（或尾部）。568行的for循环其实就是遍历消息链表，根据发送时间的先后顺序将消息插入到链表中。 2.2.3 消息加入链表后是否应该主动唤醒线程？除了需要将新消息插入到链表的合适位置，enqueueMessage还要决定是否唤醒MessageQueue所在的线程。MessageQueue的mBlocked字段记录了其所属线程是否已经发生阻塞（被挂起），该字段在消息处理的过程中被赋值。 当新消息插入到链表头部时，needWake = mBlocked： 如果MessageQueue此时已经发生阻塞，则新消息插入头部时，需要唤醒阻塞线程，以便让它根据头部的新消息重新决定处理逻辑（可能是立即处理，也可能是延时处理）。 如果MessageQueue此时未发生阻塞，则新消息插入头部后无需做多余处理。它只需要静静地等在那里，线程处理完手中的消息后自然会同它碰面。 当新消息插入到链表中间（或尾部）时，needWake的赋值变得复杂起来。这主要是由于异步消息和同步屏障的存在。 同步屏障像是一个守卫，当消息链表的头部是一个同步屏障时，后续的同步消息都无法被放行，即便这些消息已经满足发送的时间要求。此时，链表上的异步消息却不受影响，它们照常按照发送时间的逻辑，顺利地被处理。 同步屏障是一种特殊的Message，它的target为null，表明这个消息是不需要被处理的，而普通消息的target都是最终来处理该消息的Handler。通过MessageQueue的postSyncBarrier方法可以放置同步屏障，只不过这个方法是hide的，而且从Android P开始，反射调用非 SDK 的接口被限制了。虽然网上有一些手段可以绕开这种限制，但Google的本意应该是不想让开发者再使用同步屏障了。与之对应，撤除同步屏障的方法是removeSyncBarrier。 /frameworks/base/core/java/android/os/MessageQueue.java 461 public int postSyncBarrier() {462 return postSyncBarrier(SystemClock.uptimeMillis());463 } 465 private int postSyncBarrier(long when) {466 // Enqueue a new sync barrier token.467 // We don't need to wake the queue because the purpose of a barrier is to stall it.468 synchronized (this) {469 final int token = mNextBarrierToken++;470 final Message msg = Message.obtain();471 msg.markInUse();472 msg.when = when;473 msg.arg1 = token;474475 Message prev = null;476 Message p = mMessages;477 if (when != 0) {478 while (p != null &amp;&amp; p.when &lt;= when) {479 prev = p;480 p = p.next;481 }482 }483 if (prev != null) { // invariant: p == prev.next484 msg.next = p;485 prev.next = msg;486 } else {487 msg.next = p;488 mMessages = msg;489 }490 return token;491 }492 } 同步消息和异步消息的唯一差异在于Message的flag是否被置上FLAG_ASYNCHRONOUS标志位。这个标志位只在setAsynchronous方法中被改变。如果Handler的mAsynchronous为true，则通过该Handler发送的消息默认都是异步；反之，默认都是同步。除此以外，我们也可以通过消息的setAsynchronous方法来单独地给某个方法设置是否异步。 /frameworks/base/core/java/android/os/Message.java 447 public boolean isAsynchronous() {448 return (flags &amp; FLAG_ASYNCHRONOUS) != 0;449 } 477 public void setAsynchronous(boolean async) {478 if (async) {479 flags |= FLAG_ASYNCHRONOUS;480 } else {481 flags &amp;= ~FLAG_ASYNCHRONOUS;482 }483 } 回到新消息插入到链表中间（或尾部）时needWake的赋值，needWake在遍历之初被赋值如下： /frameworks/base/core/java/android/os/MessageQueue.java 566 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); 只有当MessageQueue所在的线程阻塞，链表头部为同步屏障，且新消息为异步消息时，needWake才为true。三者缺一不可。 mBlocked为false，表明线程未阻塞，自然不需要唤醒。 p.target != null，表明头部消息有效，此时即便mBlocked为true，这时候的阻塞也是有超时的，超时时间到达后，线程自动唤醒，无需外部唤醒。 msg.isAsynchronous() = false，表明新消息为同步消息，此时若头部消息为同步屏障，则新消息也无法被放行，唤醒线程也没用，干脆不唤醒。 另外在遍历的过程中，如果发现新消息的前面有另一个消息为异步消息，则needWake重新置为false。这种情况表明原有的异步消息为线程设置了有超时的阻塞，当下时间未达到异步消息的发送时间，所以mBlocked为true。但由于此次阻塞设有超时，所以并不需要外不唤醒。 线程的阻塞相当于人类的睡眠，从阻塞状态中恢复有两种可能，一种是超时唤醒，另一个是外部唤醒。类比到人类的睡眠，人从睡梦中被叫醒也有两种可能，一种是自己定闹钟，闹钟响后将自己叫醒，另一种是被别人拍醒（不考虑自然醒，因为自然醒本质也是闹钟叫醒，只不过这个闹钟是生物钟）。 2.2.4 如何主动唤醒线程？上面介绍了是否应该主动唤醒线程，如果回答“需要”的话，那我们又该怎样去唤醒线程呢？ /frameworks/base/core/java/android/os/MessageQueue.java 584 nativeWake(mPtr); 通过nativeWake的native方法，我们就可以实现唤醒MessageQueue所在线程的目的。它对应的JNI方法是android_os_MessageQueue_nativeWake。传入的mPtr实际上是native对象的指针，它被存在一个Java的字段中，用于Java层和native层的互动。 mPtr被转换成NativeMessageQueue对象(c++对象)的指针，紧接着调用NativeMessageQueue对象的wake方法。 /frameworks/base/core/jni/android_os_MessageQueue.cpp 194static void android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jlong ptr) {195 NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);196 nativeMessageQueue-&gt;wake();197} 再追踪下去，发现调用的是NativeMessageQueue中mLooper变量的wake方法。最终只干了一件事：往native层的Looper对象的mWakeEventFd中写一个“1”。结合2.1中对Epoll机制的描述，mWakeEventFd上有可读数据时，epfd将会监测到该事件，并将线程从挂起状态恢复为运行状态。 /frameworks/base/core/jni/android_os_MessageQueue.cpp 121void NativeMessageQueue::wake() {122 mLooper-&gt;wake();123} /system/core/libutils/Looper.cpp 398void Looper::wake() {399#if DEBUG_POLL_AND_WAKE400 ALOGD(\"%p ~ wake\", this);401#endif402403 uint64_t inc = 1;404 ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &amp;inc, sizeof(uint64_t)));405 if (nWrite != sizeof(uint64_t)) {406 if (errno != EAGAIN) {407 LOG_ALWAYS_FATAL(\"Could not write wake signal to fd %d: %s\",408 mWakeEventFd, strerror(errno));409 }410 }411} 2.3 消息处理过程对于想要运行消息机制的线程而言，除了需要通过Looper.prepare来创建属于自己的Looper和MessageQueue，还需要调用Looper.loop来真正的轮询、处理消息。 /frameworks/base/core/java/android/os/Looper.java 127 public static Looper getMainLooper() {128 synchronized (Looper.class) {129 return sMainLooper;130 }131 }132133 /**134 * Run the message queue in this thread. Be sure to call135 * {@link #quit()} to end the loop.136 */137 public static void loop() {138 final Looper me = myLooper();139 if (me == null) {140 throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");141 }142 final MessageQueue queue = me.mQueue;143144 // Make sure the identity of this thread is that of the local process,145 // and keep track of what that identity token actually is.146 Binder.clearCallingIdentity();147 final long ident = Binder.clearCallingIdentity();148149 // Allow overriding a threshold with a system prop. e.g.150 // adb shell 'setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start'151 final int thresholdOverride =152 SystemProperties.getInt(\"log.looper.\"153 + Process.myUid() + \".\"154 + Thread.currentThread().getName()155 + \".slow\", 0);156157 boolean slowDeliveryDetected = false;158159 for (;;) {160 Message msg = queue.next(); // might block161 if (msg == null) {162 // No message indicates that the message queue is quitting.163 return;164 }165166 // This must be in a local variable, in case a UI event sets the logger167 final Printer logging = me.mLogging;168 if (logging != null) {169 logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" +170 msg.callback + \": \" + msg.what);171 }172173 final long traceTag = me.mTraceTag;174 long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;175 long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;176 if (thresholdOverride &gt; 0) {177 slowDispatchThresholdMs = thresholdOverride;178 slowDeliveryThresholdMs = thresholdOverride;179 }180 final boolean logSlowDelivery = (slowDeliveryThresholdMs &gt; 0) &amp;&amp; (msg.when &gt; 0);181 final boolean logSlowDispatch = (slowDispatchThresholdMs &gt; 0);182183 final boolean needStartTime = logSlowDelivery || logSlowDispatch;184 final boolean needEndTime = logSlowDispatch;185186 if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) {187 Trace.traceBegin(traceTag, msg.target.getTraceName(msg));188 }189190 final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;191 final long dispatchEnd;192 try {193 msg.target.dispatchMessage(msg);194 dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;195 } finally {196 if (traceTag != 0) {197 Trace.traceEnd(traceTag);198 }199 }200 if (logSlowDelivery) {201 if (slowDeliveryDetected) {202 if ((dispatchStart - msg.when) &lt;= 10) {203 Slog.w(TAG, \"Drained\");204 slowDeliveryDetected = false;205 }206 } else {207 if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, \"delivery\",208 msg)) {209 // Once we write a slow delivery log, suppress until the queue drains.210 slowDeliveryDetected = true;211 }212 }213 }214 if (logSlowDispatch) {215 showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, \"dispatch\", msg);216 }217218 if (logging != null) {219 logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback);220 }221222 // Make sure that during the course of dispatching the223 // identity of the thread wasn't corrupted.224 final long newIdent = Binder.clearCallingIdentity();225 if (ident != newIdent) {226 Log.wtf(TAG, \"Thread identity changed from 0x\"227 + Long.toHexString(ident) + \" to 0x\"228 + Long.toHexString(newIdent) + \" while dispatching to \"229 + msg.target.getClass().getName() + \" \"230 + msg.callback + \" what=\" + msg.what);231 }232233 msg.recycleUnchecked();234 }235 } 159行开始的for循环在正常状态下永远不会退出，除非调用Looper或MessageQueue的quit方法。在每一次循环的过程中，都做了以下三件事： 取出消息链表中可被处理的头部消息。 执行消息所对应的Handler的dispatchMessage方法，并记录消息处理的delivery时间和dispatch时间，用于监测消息队列的运转状态是否正常。 回收此消息。 在这三个步骤中，需要详细分析的是1和2。1需要较多的篇幅来阐述，因此我们先分析2的过程。 2.3.1 Delievery Time和Dispatch Time分别指的是什么？Delievery Time: 待发送的消息通常都有一个预设的发送时间点，也即message的when字段。当这个消息从消息链表中被取出时，记录另一个时间点，称之为dispatchStart。正常情况下，dispatchStart和msg.when相同，表明消息按照预设的时间点被取出。非正常情况下，如果前面消息处理时间过长，将会延误后续消息的发送（因为消息链表是串行发送的）。这个道理和排队的情形很相似。 DelieveryTime = dispatchStart - msg.when，表示消息被取出的时间点和预设的时间点之间的差距。差值较小，表明消息基本是按照预设的时间来取出的。差值较大，则表明消息队列有些拥堵，可能是前面的消息过多，也可能是前面某个消息的处理耗时过长。总之，当前这个消息并没有按照预设的时间被取出，而是有些滞后了。 Dispatch Time: 消息的处理时间，也即消息所对应Handler的dispatchMessage方法的运行时间。每个消息都有属于自己的处理方法，其中可能包含某些耗时操作。因此记录下dispatch time，当这个时间超过某个阈值时给出相应的警告，可以帮助开发者了解程序的性能以及运行时的压力。 2.3.2 消息处理最终执行哪个方法？消息处理会调用Handler的dispatchMessage方法来对消息进行处理。在这个方法内部，我们可以看出一个消息会有三种处理方式。三种处理方式并非随机选择，而是具有一定的优先级的。 当message本身的callback字段不为空时，按照callback指定的方式对消息进行处理。 当条件1不满足，且Handler对象的mCallback字段不为空时，按照mCallback指定的方式对消息进行处理。 当条件1、2均不满足时，按照Handler类的handleMessage方法对消息进行处理。 /frameworks/base/core/java/android/os/Handler.java 97 public void dispatchMessage(Message msg) {98 if (msg.callback != null) {99 handleCallback(msg);100 } else {101 if (mCallback != null) {102 if (mCallback.handleMessage(msg)) {103 return;104 }105 }106 handleMessage(msg);107 }108 } 以下分别列举满足3种处理方式的例子： 当message本身的callback字段不为空时，按照callback指定的方式对消息进行处理。 /frameworks/base/core/java/android/speech/tts/TextToSpeechService.java 579 Runnable runnable = new Runnable() {580 @Override581 public void run() {582 if (setCurrentSpeechItem(speechItem)) {583 speechItem.play();584 removeCurrentSpeechItem();585 } else {586 // The item is alreadly flushed. Stopping.587 speechItem.stop();588 }589 }590 };591 Message msg = Message.obtain(this, runnable); 当条件1不满足，且Handler对象的mCallback字段不为空时，按照mCallback指定的方式对消息进行处理。 /frameworks/base/services/core/java/com/android/server/GraphicsStatsService.java 110 mWriteOutHandler = new Handler(bgthread.getLooper(), new Handler.Callback() {111 @Override112 public boolean handleMessage(Message msg) {113 switch (msg.what) {114 case SAVE_BUFFER:115 saveBuffer((HistoricalBuffer) msg.obj);116 break;117 case DELETE_OLD:118 deleteOldBuffers();119 break;120 }121 return true;122 }123 }); 当条件1、2均不满足时，按照Handler类的handleMessage方法对消息进行处理。 /frameworks/base/services/core/java/com/android/server/pm/ProcessLoggingHandler.java 35public final class ProcessLoggingHandler extends Handler {............47 @Override48 public void handleMessage(Message msg) {49 switch (msg.what) {50 case LOG_APP_PROCESS_START_MSG: {51 Bundle bundle = msg.getData();52 String processName = bundle.getString(\"processName\");53 int uid = bundle.getInt(\"uid\");54 String seinfo = bundle.getString(\"seinfo\");55 String apkFile = bundle.getString(\"apkFile\");56 int pid = bundle.getInt(\"pid\");57 long startTimestamp = bundle.getLong(\"startTimestamp\");58 String apkHash = computeStringHashOfApk(apkFile);59 SecurityLog.writeEvent(SecurityLog.TAG_APP_PROCESS_START, processName,60 startTimestamp, uid, pid, seinfo, apkHash);61 break;62 }63 case INVALIDATE_BASE_APK_HASH_MSG: {64 Bundle bundle = msg.getData();65 mProcessLoggingBaseApkHashes.remove(bundle.getString(\"apkFile\"));66 break;67 }68 }69 } 开发者定义的都是Handler的子类（譬如上面的ProcessingLoggingHandler），如果需要最终由Handler类的handleMessage来对消息进行处理，则子类中必须覆盖父类的handleMessage方法。否则将不会对消息进行处理，因为父类（Handler）的handleMessage方法是一个空方法。 这种阶梯式处理消息的设计，可以给予开发者更大的自由度。 2.3.3 如何取出下一个消息？接下来重点讲述如何取出消息链表中可被处理的头部消息。让我们走进MessageQueue的next方法。 /frameworks/base/core/java/android/os/Looper.java 160 Message msg = queue.next(); // might block /frameworks/base/core/java/android/os/MessageQueue.java 310 Message next() {311 // Return here if the message loop has already quit and been disposed.312 // This can happen if the application tries to restart a looper after quit313 // which is not supported.314 final long ptr = mPtr;315 if (ptr == 0) {316 return null;317 }318319 int pendingIdleHandlerCount = -1; // -1 only during first iteration320 int nextPollTimeoutMillis = 0;321 for (;;) {322 if (nextPollTimeoutMillis != 0) {323 Binder.flushPendingCommands();324 }325326 nativePollOnce(ptr, nextPollTimeoutMillis);327328 synchronized (this) {329 // Try to retrieve the next message. Return if found.330 final long now = SystemClock.uptimeMillis();331 Message prevMsg = null;332 Message msg = mMessages;333 if (msg != null &amp;&amp; msg.target == null) {334 // Stalled by a barrier. Find the next asynchronous message in the queue.335 do {336 prevMsg = msg;337 msg = msg.next;338 } while (msg != null &amp;&amp; !msg.isAsynchronous());339 }340 if (msg != null) {341 if (now &lt; msg.when) {342 // Next message is not ready. Set a timeout to wake up when it is ready.343 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);344 } else {345 // Got a message.346 mBlocked = false;347 if (prevMsg != null) {348 prevMsg.next = msg.next;349 } else {350 mMessages = msg.next;351 }352 msg.next = null;353 if (DEBUG) Log.v(TAG, \"Returning message: \" + msg);354 msg.markInUse();355 return msg;356 }357 } else {358 // No more messages.359 nextPollTimeoutMillis = -1;360 }361362 // Process the quit message now that all pending messages have been handled.363 if (mQuitting) {364 dispose();365 return null;366 }367368 // If first time idle, then get the number of idlers to run.369 // Idle handles only run if the queue is empty or if the first message370 // in the queue (possibly a barrier) is due to be handled in the future.371 if (pendingIdleHandlerCount &lt; 0372 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) {373 pendingIdleHandlerCount = mIdleHandlers.size();374 }375 if (pendingIdleHandlerCount &lt;= 0) {376 // No idle handlers to run. Loop and wait some more.377 mBlocked = true;378 continue;379 }380381 if (mPendingIdleHandlers == null) {382 mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];383 }384 mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);385 }386387 // Run the idle handlers.388 // We only ever reach this code block during the first iteration.389 for (int i = 0; i &lt; pendingIdleHandlerCount; i++) {390 final IdleHandler idler = mPendingIdleHandlers[i];391 mPendingIdleHandlers[i] = null; // release the reference to the handler392393 boolean keep = false;394 try {395 keep = idler.queueIdle();396 } catch (Throwable t) {397 Log.wtf(TAG, \"IdleHandler threw exception\", t);398 }399400 if (!keep) {401 synchronized (this) {402 mIdleHandlers.remove(idler);403 }404 }405 }406407 // Reset the idle handler count to 0 so we do not run them again.408 pendingIdleHandlerCount = 0;409410 // While calling an idle handler, a new message could have been delivered411 // so go back and look again for a pending message without waiting.412 nextPollTimeoutMillis = 0;413 }414 } 首先分析326行的nativePollOnce方法，它的作用是设定下一次发送的时间或挂起线程。其对应的JNI方法为android_os_MessageQueue_nativePollOnce。内部调用NativeMessageQueue的pollOnce函数。 /frameworks/base/core/jni/android_os_MessageQueue.cpp 188static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj,189 jlong ptr, jint timeoutMillis) {190 NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);191 nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);192} NativeMessageQueue的pollOnce函数进一步调用Looper的pollOnce函数，并传入timeoutMills参数。 /frameworks/base/core/jni/android_os_MessageQueue.cpp 107void NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) {108 mPollEnv = env;109 mPollObj = pollObj;110 mLooper-&gt;pollOnce(timeoutMillis);111 mPollObj = NULL;112 mPollEnv = NULL;113114 if (mExceptionObj) {115 env-&gt;Throw(mExceptionObj);116 env-&gt;DeleteLocalRef(mExceptionObj);117 mExceptionObj = NULL;118 }119} 一层层往下走，发现最终调用的是Looper的pollInner函数，最终通过系统调用epoll_wait陷入内核态。 /system/core/libutils/Looper.cpp 242 int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis); 传入epoll_wait的timeoutMillis参数将直接决定epoll的行为。这里可以分为三种情况： timeoutMillis = 0，意味着无需等待。检测epfd上是否有事件，有或没有都将直接返回，继续执行后面的操作。 timeoutMillis &gt; 0，意味着epoll_wait有超时时间。对于Level Trigger的fd事件（这里是这种情况），在调用epoll_wait的时候会首先查看该事件是否已经存在。如果存在则直接返回，否则线程被挂起呈现阻塞状态，等待超时时间到达后恢复至运行状态。在超时等待的这段时间内，如果有新的消息被加入到链表头部，发送线程将会唤醒此线程以重新决定timeoutMillis的值。 timeoutMillis = -1，epoll_wait会首先查看监测事件是否已经存在，如果存在则直接返回，否则将无限期地等待下去，直到有新消息到来，其他线程唤醒此线程。 通过320行可知，nextPollTimeoutMillis在第一次循环时被设置为0，意味着第一次循环将跳过epoll_wait的等待，直接去检查消息链表的状态。 /frameworks/base/core/java/android/os/MessageQueue.java 320 int nextPollTimeoutMillis = 0;321 for (;;) {322 if (nextPollTimeoutMillis != 0) {323 Binder.flushPendingCommands();324 }325326 nativePollOnce(ptr, nextPollTimeoutMillis); 330-339行的主要工作是取出链表中第一个可被处理的消息。上文提到，MessageQueue只用了一个字段（mMessages）来记录消息链表的头部消息，所以通过332行便可以取到头部消息。如果链表头部是同步屏障，那么就要遍历去寻找链表中第一个异步消息。 /frameworks/base/core/java/android/os/MessageQueue.java 330 final long now = SystemClock.uptimeMillis();331 Message prevMsg = null;332 Message msg = mMessages;333 if (msg != null &amp;&amp; msg.target == null) {334 // Stalled by a barrier. Find the next asynchronous message in the queue.335 do {336 prevMsg = msg;337 msg = msg.next;338 } while (msg != null &amp;&amp; !msg.isAsynchronous());339 } 当取出的可处理消息为null时，意味着链表中暂时没有消息可以被处理，所以将nextPollTimeoutMillis置为-1，让next下一次轮询的时候直接通过epoll_wait将线程挂起休息。 反之则需要有进一步的处理，分两种情况讨论： 当下时间 &lt; 该消息预定的处理时间，此时不应处理消息，需要等待时机成熟。于是将nextPollTimeoutMillis设置为当下时间和预定处理时间之间的差值，保证超时后能够再次轮询此消息，并进行相应处理。 当下时间 ≥ 该消息预定的处理时间，此时消息已经成熟，应该被处理。此时将mBlocked置为false，表明该线程处于Runnable状态，并且马上就要执行消息的处理方法。接着重构链表，将此消息从链表中删除。最后返回此消息到Looper的loop方法进行消息的实际处理。 /frameworks/base/core/java/android/os/MessageQueue.java 340 if (msg != null) {341 if (now &lt; msg.when) {342 // Next message is not ready. Set a timeout to wake up when it is ready.343 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);344 } else {345 // Got a message.346 mBlocked = false;347 if (prevMsg != null) {348 prevMsg.next = msg.next;349 } else {350 mMessages = msg.next;351 }352 msg.next = null;353 if (DEBUG) Log.v(TAG, \"Returning message: \" + msg);354 msg.markInUse();355 return msg;356 }357 } else {358 // No more messages.359 nextPollTimeoutMillis = -1;360 } 2.3.4 IdleHandler有什么用？在MessageQueue的next方法中，还会对IdleHandler进行处理。IdleHandler，顾名思义，表示线程空闲时才需要去执行的一些操作。如果此时链表头部的消息为空或尚未到达发送时间，则表明线程空闲，因此可以去处理一些杂事（IdleHandler里的工作）。 通过319行可知，pendingIdleHandlerCount最初始被赋值为-1。 /frameworks/base/core/java/android/os/MessageQueue.java 319 int pendingIdleHandlerCount = -1; // -1 only during first iteration 所以第一次运行到371行时，pendingIdleHandlerCount必定小于0。通过373行到384行，将mIdleHandlers（类型为ArrayList）中的元素赋值给mPendingIdleHandlers（类型为数组）。之所以不直接使用mIdleHandlers来进行遍历，是因为遍历处理mIdleHandles时无需持有MessageQueue的monitor lock，于是干脆将锁释放，让其他线程可以在处理mPendingIdleHandlers中的元素时，同时往mIdleHandlers中插入新的元素。 如果不需要对IdleHandler处理，或者mIdleHandlers中没有需要处理的对象，则设置mBlocked为true（377行），在下一轮循环的过程中会通过epoll_wait将本线程挂起。需要注意的一点是，如果此次next()方法能够取出有效消息进行处理，代码是不会执行到371行及以下的位置，它会在355行直接返回。 接下来便是遍历mIdleHandlers中的元素，并执行它们的queueIdle方法的过程。如果queueIdle返回false，表明该IdleHandler只会执行一次，执行完之后就从mIdleHandlers列表中删除。 /frameworks/base/core/java/android/os/MessageQueue.java 371 if (pendingIdleHandlerCount &lt; 0372 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) {373 pendingIdleHandlerCount = mIdleHandlers.size();374 }375 if (pendingIdleHandlerCount &lt;= 0) {376 // No idle handlers to run. Loop and wait some more.377 mBlocked = true;378 continue;379 }380381 if (mPendingIdleHandlers == null) {382 mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];383 }384 mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);385 }386387 // Run the idle handlers.388 // We only ever reach this code block during the first iteration.389 for (int i = 0; i &lt; pendingIdleHandlerCount; i++) {390 final IdleHandler idler = mPendingIdleHandlers[i];391 mPendingIdleHandlers[i] = null; // release the reference to the handler392393 boolean keep = false;394 try {395 keep = idler.queueIdle();396 } catch (Throwable t) {397 Log.wtf(TAG, \"IdleHandler threw exception\", t);398 }399400 if (!keep) {401 synchronized (this) {402 mIdleHandlers.remove(idler);403 }404 }405 }406407 // Reset the idle handler count to 0 so we do not run them again.408 pendingIdleHandlerCount = 0;409410 // While calling an idle handler, a new message could have been delivered411 // so go back and look again for a pending message without waiting.412 nextPollTimeoutMillis = 0;413 }414 } 3 总结本文从以下三个方面详细介绍了Android中的消息机制： 消息队列准备过程 消息发送过程 消息处理过程 分析了消息从哪里来，到哪里去的问题。顺着这条主线，也穿插讲述了消息机制中一些不为人熟知的机制：同步屏障、epoll机制、delievery time以及IdleHandler的处理时机等。希望这些分析能够帮助到大家。","link":"/Android消息机制/"}],"tags":[{"name":"Binder","slug":"Binder","link":"/tags/Binder/"},{"name":"RPC","slug":"RPC","link":"/tags/RPC/"},{"name":"消息机制","slug":"消息机制","link":"/tags/消息机制/"},{"name":"Handler","slug":"Handler","link":"/tags/Handler/"},{"name":"Message","slug":"Message","link":"/tags/Message/"}],"categories":[{"name":"Android Framework","slug":"Android-Framework","link":"/categories/Android-Framework/"},{"name":"Binder","slug":"Android-Framework/Binder","link":"/categories/Android-Framework/Binder/"}]}